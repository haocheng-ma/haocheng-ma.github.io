<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta name="google-site-verification" content="IZHz75ntcIC4eGlb8HT7ZmeXprRk-iWg8hQMbMEmd84"> <meta http-equiv="Permissions-Policy" content="interest-cohort=()"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> White Paper: The VAST Data Platform | Haocheng Ma </title> <meta name="author" content="Haocheng Ma"> <meta name="description" content="Translated version of VAST's white paper (part 1)."> <meta name="keywords" content="haocheng ma, academic-website, portfolio-website"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css2?family=Lato:ital,wght@0,400;0,700;1,400;1,700&amp;family=Mulish:ital,wght@0,200..1000;1,200..1000&amp;family=Nunito:ital,wght@0,200..1000;1,200..1000&amp;family=Open+Sans:ital,wght@0,300..800;1,300..800&amp;family=Roboto:ital,wght@0,100..900;1,100..900&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link defer href="/assets/css/bootstrap-toc.min.css?6f5af0bb9aab25d79b2448143cbeaa88" rel="stylesheet"> <link rel="shortcut icon" href="/assets/img/icon_pic.ico?201b24740f59dd40b09d1d7ec803eeaa"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://mahaocheng.me/blog/2025/vast-data-platform/"> <script src="/assets/js/theme.js?9a0c749ec5240d9cda97bc72359a72c0"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>initTheme();</script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Haocheng</span> Ma </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="row"> <div class="col-sm-3"> <nav id="toc-sidebar" class="sticky-top"></nav> </div> <div class="col-sm-9"> <div class="post"> <header class="post-header"> <h1 class="post-title">White Paper: The VAST Data Platform</h1> <p class="post-meta"> Created in August 14, 2025 </p> <p class="post-tags"> <a href="/blog/2025"> <i class="fa-solid fa-calendar fa-sm"></i> 2025 </a>   ·   <a href="/blog/tag/vast"> <i class="fa-solid fa-hashtag fa-sm"></i> VAST</a>   <a href="/blog/tag/ssd"> <i class="fa-solid fa-hashtag fa-sm"></i> SSD</a>   <a href="/blog/tag/cluster"> <i class="fa-solid fa-hashtag fa-sm"></i> Cluster</a>   ·   <a href="/blog/category/storage"> <i class="fa-solid fa-tag fa-sm"></i> Storage</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <p>Note: 本文是借助 AI 翻译的 VAST 白皮书，原文请见：<a href="https://www.vastdata.com/whitepaper/#TheVASTDataPlatform" rel="external nofollow noopener" target="_blank">The VAST Data Platform</a>.</p> <hr> <h2 id="how-it-works">How It Works</h2> <p>VAST Data Platform 是一个统一的、容器化的软件环境，能够为不同的应用场景和使用者提供多样化的数据处理功能。</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2025-08-14-vast-data-platform/1.png" sizes="95vw"></source> <img src="/assets/img/2025-08-14-vast-data-platform/1.png" class="img-fluid rounded z-depth-0 mx-auto d-block" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p>这是首个同时原生支持结构化表格数据（包括原生写入或通过 Parquet 等开放格式转换而来）、数据流与事件通知（兼容 Kafka 接口）、以及非结构化数据（通过高性能企业级文件协议如 NFS、SMB、S3 获取）的数据平台。平台还集成了无服务器计算引擎（支持 Python 编写的函数），使数据“活”起来，构建出一个支持递归式 AI 计算的执行环境。数据事件可触发函数运行，例如自动编目、AI 推理、元数据增强，乃至进一步的 AI 模型再训练。通过将数据与代码深度结合，系统可以在新数据和长期数据上持续执行计算任务，实现“实时学习”，通过当前交互与历史经验的联动，让系统愈发智能。</p> <p>不同于传统的批处理架构，VAST 架构利用实时写缓冲区，在数据写入系统的过程中立即捕获并处理数据。无论是小规模、随机的写操作（如事件流、数据库写入），还是大规模并行写操作（如应用生成的检查点文件），都能被即时写入持久性内存中，并能立刻用于检索和与系统中其他数据集的相关性分析。系统的核心数据大多存储在低成本、具备超大规模能力的闪存归档存储中，使得整个平台兼顾实时性与经济性。</p> <p>该平台专注于深度学习任务，致力于从非结构化数据中提取和编排结构信息，构建起基于自然世界感知数据的自动化与发现引擎，从而为 AI 推理与认知提供坚实的数据基础。</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2025-08-14-vast-data-platform/2.png" sizes="95vw"></source> <img src="/assets/img/2025-08-14-vast-data-platform/2.png" class="img-fluid rounded z-depth-0 mx-auto d-block" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p>系统的各项功能模块被整合进一个统一的平台中，主要由以下几个核心组件构成：</p> <p><strong>VAST DataStore</strong> 是整个平台的存储基础，前身即 VAST 的 Universal Storage（通用存储）产品。它负责将数据持久化，并通过多种协议对外提供读写访问，满足不同应用的接入需求。DataStore 可在单一数据中心扩展至艾字节（Exabyte）级别，打破了长期以来在存储系统中“性能与容量不可兼得”的固有限制，使用户能够在一层成本可控的闪存介质上同时管理文件、对象和表格数据，从而实现任意规模、任意深度的数据计算能力。</p> <p>DataStore 的核心使命是采集并服务于来自自然世界的大量原始、非结构化及流式数据。为了进一步组织这些数据，</p> <p><strong>VAST DataBase</strong> 作为平台的数据库管理服务，负责将结构化表格数据写入系统，并支持对庞大的表格数据和已编目的元数据进行实时、细粒度的查询。不同于传统数据库系统，VAST DataBase 同时具备 OLTP 行式数据库的事务能力、列式数据结构的分析查询性能（如基于闪存的数据仓库），以及数据湖级别的规模与成本优势。</p> <p>DataBase 的最终使命，是组织 DataStore 中的数据知识语料，并对非结构化数据进行语义层面的编目与理解。</p> <p><strong>VAST DataEngine</strong> 是该平台的声明式函数执行环境，支持类似 AWS Lambda 的无服务器函数部署与事件通知功能，运行于标准 Linux 容器中。它内建调度器与成本优化器，可在 CPU、GPU 和 DPU 架构上运行，充分利用可扩展的通用计算资源，使数据具备“计算生命”。与传统计算方法不同，DataEngine 架起了事件驱动架构与数据驱动架构之间的桥梁，能够让系统实时接入、分析、推理并训练来自各类数据的洞察结果。</p> <p>DataEngine 的最终使命，是通过推理与分析，理解数据背后的特征，将原始的非结构化数据转化为有意义的信息。</p> <p><strong>VAST DataSpace</strong> 则进一步将上述能力扩展至多个数据中心之间，构建起统一的计算结构和存储命名空间，旨在打破地理分布式计算中的经典瓶颈。DataSpace 通过元数据同步和远程缓存，实现全球范围的数据访问，并允许各个站点在精细粒度（如文件级、对象级、表格级）上临时接管一致性管理。借助这种去中心化且细粒度的控制方式，VAST Data Platform 成为一个全球性数据平台，在保证严格应用一致性的同时，也为远程函数提供了高性能支持。DataSpace 通过智能预取与数据流水线机制，不仅打通了信息孤岛，还能保持数据管道充盈，让远程 CPU 与 GPU 时刻保持高效运转。</p> <p>DataEngine 也可以灵活叠加在这个统一命名空间之上，在“数据重于计算资源”的场景中将函数调度至数据侧执行；反之，在数据侧计算资源紧张时将数据传送到函数所在位置，从而有效对抗“计算重力”和“数据重力”，助力组织构建全球性的 AI 计算环境。</p> <p>DataSpace 的最终使命，是作为平台连接自然世界的接口，实现全球访问能力，支持跨地域的联邦式 AI 训练与推理任务。</p> <p>现在你已经对 VAST Data Platform 有了基本了解，我们可以回顾大数据与深度学习工作负载的典型需求，看看 VAST 平台在各项关键指标上的契合程度：</p> <table> <thead> <tr> <th>Category</th> <th>Big Data</th> <th>Deep Learning</th> <th>VAST Data Platform</th> </tr> </thead> <tbody> <tr> <td>Data Types</td> <td>Structured &amp; Semi-Structured, Tables, JSON, Parquet</td> <td>Unstructured Text, Video, Instruments, etc.</td> <td>Structured and Unstructured</td> </tr> <tr> <td>Processor Type</td> <td>CPUs</td> <td>GPUs, AI Processors &amp; DPUs</td> <td>Orchestrates across and manages CPU, GPU, DPU, etc.</td> </tr> <tr> <td>Storage Protocols</td> <td>S3</td> <td>S3, RDMA file for GPUs</td> <td>S3, NFSoRDMA, SMB</td> </tr> <tr> <td>Dataset Size</td> <td>TB-scale warehouses</td> <td>TB–EB scale volumes</td> <td>100 TB – EBs</td> </tr> <tr> <td>Namespace</td> <td>Single-Site</td> <td>Globally-Federated</td> <td>Globally-Federated</td> </tr> <tr> <td>Processing Paradigm</td> <td>Data-Driven (Batch)</td> <td>Continuous (Real-Time)</td> <td>Real-time and batch</td> </tr> </tbody> </table> <h2 id="architecting-the-vast-data-platform">Architecting the VAST Data Platform</h2> <p>VAST Data Platform 的架构由一组服务进程组成，这些进程既相互通信，也与外部客户端交互，共同提供丰富的数据服务。为了更清晰地解释这些服务及其协作方式，可以将它们类比为类似 OSI 网络模型七层结构中的“分层服务”。</p> <p>不过，与 OSI 模型那种具有严格分层、各层协议边界清晰的架构不同，VAST 的“分层”更像是一种帮助理解的方式，并不代表系统中真的存在硬性的模块边界。一些服务可能会跨越多个逻辑层级提供功能，同时各层之间的通信也常通过非公开接口完成。换言之，VAST 平台更像是一个灵活协同的服务集合，其架构强调功能融合而非机械分层。</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2025-08-14-vast-data-platform/3.png" sizes="95vw"></source> <img src="/assets/img/2025-08-14-vast-data-platform/3.png" class="img-fluid rounded z-depth-0 mx-auto d-block" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p>从最底层开始讲起——毕竟每个系统架构都必须建立在坚实的基础之上——VAST 平台的分层结构如下：</p> <p><strong>1. VAST DataStore</strong> 是平台的核心存储层，负责在 VAST 的全球命名空间中存储与保护数据，同时通过传统存储协议（如 NFS、SMB、S3）以及内部协议将数据提供给 VAST DataBase 与 VAST DataEngine 使用。VAST DataStore 本身由三个重要的子层组成：</p> <ul> <li> <p><strong>物理层 / 块管理层（Physical or Chunk Management Layer）</strong> 负责对 VAST Element Store 所使用的小型数据块（chunk）进行基础的数据保护与管理。它涵盖的功能包括：纠删码（Erasure Coding）、数据分布、数据压缩与去重、静态加密（Encryption at Rest）以及设备管理。这一层的作用是保障数据的可靠性、存储效率和底层硬件的运维能力。</p> </li> <li> <p><strong>逻辑层 / VAST Element Store（Logical Layer aka VAST Element Store）</strong> 基于元数据将底层数据块组织成用户可见的高层数据对象（Data Elements），例如文件、对象（object）、表格（table）和卷（volume）等。VAST Element Store 不仅将这些元素统一编入一个全球命名空间（适用于单个 VAST 集群），还可以借助 VAST DataSpace 跨集群构建一个全球一致的分布式命名空间。</p> <p>通俗讲，VAST Element Store 就像是“被伽马射线照射后的文件系统”，它以极强的灵活性将底层数据块整合成跨地域可访问的全局数据元素（如文件、对象、表格、块卷等）。 在这个层面上，系统还提供了路径或元素级的服务功能，如访问控制、数据加密、快照、克隆、数据副本等。</p> </li> <li> <p><strong>协议层（Protocol Layer）</strong> 负责为这些数据元素提供多协议的访问方式。所有协议模块是对等的、独立的，它们可以根据数据类型为外部应用程序提供完整的多协议访问能力。这意味着不论用户使用哪种接口（如 NFS、S3、SMB），都能访问相同的数据元素，并保持数据一致性。</p> </li> </ul> <p><strong>2. 执行层（The Execution Layer）</strong> 负责提供并调度计算逻辑，通过数据驱动的处理方式将数据转化为洞察。该层包含两个核心服务：</p> <ul> <li> <p><strong>VAST DataBase</strong> – 该服务负责管理结构化数据。VAST DataBase 专为满足在线事务处理（OLTP）所需的一致性、数据组织能力以及在线分析处理（OLAP）所需的复杂查询能力而设计，且具备支持当今 AI 应用所需的扩展性。 在逻辑层负责存储表格数据、协议层提供基础 SQL 访问的基础上，VAST DataBase 将这些表格进一步转化为功能完整的数据库管理系统，支持如排序键、外键、连接查询等高级数据库特性。</p> </li> <li> <p><strong>VAST DataEngine</strong> – 该组件赋予系统智能处理能力，使其能对原始数据进行处理、转换，进而推理出有价值的信息。DataEngine 可根据事件触发机制（如满足某一筛选条件的对象到达或某个 Lambda 函数被调用）对数据元素执行任务，如人脸识别、数据泄露防护扫描、视频转码等。<br> DataEngine 同时作为全球任务调度器，在公有云与私有资源构成的全球网络中，综合计算资源、数据访问性和成本等因素，将计算任务调度至最合适的执行位置。</p> </li> </ul> <p>分层架构本身并不是什么新概念——IT 系统早已习惯于将关系型数据库运行在 SAN 存储之上，再结合如 Kubernetes 这类编排引擎进行调度。但 VAST Data Platform 的革新之处在于： 一是各个服务之间打破了传统层级边界，实现了高度集成； 二是所有这些服务都运行在名为 <strong>DASE（Disaggregated Shared Everything）</strong> 的集群架构上，这种架构解耦了计算与存储资源，又能共享所有数据，从根本上提升了系统的灵活性、可扩展性与性能。</p> <h2 id="the-disaggregated-shared-everything-architecture">The Disaggregated Shared Everything Architecture</h2> <p>VAST Data Platform 是一个软件定义的平台，也就是说，它的所有核心功能都是以软件形式运行在标准的 x86 或 ARM 架构 CPU 上的容器中实现的。但这并不意味着 VAST 是为一堆低配置的 x86 服务器设计的。相反，它结合了最新的存储与网络技术，例如存储级内存（Storage Class Memory）SSD 和基于 NVMe 协议的网络结构（NVMe over Fabrics，简称 NVMe-oF），在一种被称为 <strong>DASE（Disaggregated Shared Everything，解耦共享一切）</strong> 的架构下，使 VAST 集群具备前所未有的可扩展性，彻底打破了过去“共享无物（Shared-Nothing）”和“共享存储介质（Shared-Media）”架构的性能与伸缩性限制。</p> <p>DASE 架构在数据系统集群设计中引入了两个颠覆性的理念：</p> <p><strong>第一，解耦计算资源与持久性数据及系统状态。</strong> 在 DASE 架构中，所有计算任务都由计算节点（称为 VAST Servers，也叫 CNodes）来执行，这些节点运行于无状态的容器中。这包括原本需要由传统存储控制器 CPU 执行的持久存储管理任务。通过这种方式，集群的计算资源可以完全独立于存储容量进行扩展，并可在常规数据中心网络环境中实现弹性部署。</p> <p><strong>第二，共享一切的模型让任意 CNode 都能直接访问所有数据、元数据和系统状态。</strong> 在 DASE 集群中，系统状态被存储在高可用的 NVMe SSD 中，这些 SSD 通过 NVMe JBOF（Just a Bunch of Flash）设备连接，也就是我们通常说的存储机箱。官方称这些设备为 DBoxes（Data Boxes），虽然这个名字现在已经不太常提了。每个 DBox 通过 NVMe 网络结构与计算节点相连，实现所有计算节点对数据的全局直接访问。</p> <p>集群中的每个 CNode 在启动时都会挂载 DASE 集群中的所有 SSD，因此能够直接访问整个系统中共享的状态数据。这些状态数据包括从全局数据压缩信息到数据库事务状态在内的各种“单一真实来源”，并且是统一的、未被分区的。</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2025-08-14-vast-data-platform/4.png" sizes="95vw"></source> <img src="/assets/img/2025-08-14-vast-data-platform/4.png" class="img-fluid rounded z-depth-0 mx-auto d-block" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p>从上文要点和示意图来看，你可能已经注意到，DASE 架构主要由两个基本组件组成：</p> <ul> <li> <strong>CNodes（计算节点）</strong>：负责运行平台上的全部软件服务与计算逻辑；</li> <li> <strong>DBoxes（数据盒子）</strong>：存放所有的存储介质与系统状态，是平台的持久化存储层。</li> </ul> <h3 id="vast-servers-cnodes">VAST Servers (CNodes)</h3> <p>VAST 服务器，也就是 CNode（计算节点），是 VAST Data Platform 的“智能大脑”，负责整个系统的管理与运作。这些节点的功能包括：保护 VAST Element Store 中的数据、处理数据库查询、判断应将某段体育赛事精彩片段转码到哪个位置以用于下一段回放视频，以及处理整个数据流的计算逻辑。</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2025-08-14-vast-data-platform/5.png" sizes="95vw"></source> <img src="/assets/img/2025-08-14-vast-data-platform/5.png" class="img-fluid rounded z-depth-0 mx-auto d-block" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p>VAST Data Platform 以一组无状态容器的形式运行在一个或多个 x86 服务器构成的集群上。术语 CNode（即 compute node，计算节点）通常指运行在 VAST 集群中的 VAST Server 容器，但有时也用于指代承载该容器的物理服务器。例如，当你看到类似“每个 CNode 可使用一张 100Gbps 网卡同时处理集群内通信与客户端连接”这样的描述时，这里的 CNode 实际是指运行容器的服务器硬件。</p> <p>在每个 CNode 启动时，都会通过 NVMe-oF 协议挂载整个集群中的所有 SCM（Storage Class Memory）和超大规模闪存 SSD。这意味着，每个 CNode 都可以直接访问整个集群中的所有数据和元数据。在 DASE 架构中，一切资源——每块存储设备、每一个元数据结构、系统内每一个事务状态——都是在所有 CNode 之间共享的。</p> <p>在这种架构中，节点之间没有“所有权”的概念。也就是说，CNode 不拥有任何特定的存储设备或卷的元数据。当某个 CNode 需要读取一个文件时，它会从 SCM SSD 中读取该文件的元数据，以确定数据在超大规模 SSD 上的具体位置，然后直接从这些 SSD 中读取所需数据。整个过程中无需向其他节点请求访问权限。</p> <p>对于常见的简单存储请求（如读取或写入），每个 CNode 都可以自行独立完成，无需与集群中的其他节点协同处理。而对于更复杂的请求，例如数据库查询或 VAST DataEngine 中的函数执行，系统会通过 VAST DataEngine 自动将任务并行分配给多个 CNode 执行。关于这一部分的详细内容，我们将在介绍 VAST DataBase 和 VAST DataEngine 时进一步展开。</p> <h3 id="stateless-containers">Stateless Containers</h3> <p>运行在 DASE 集群中的 CNode 容器是无状态的，这意味着任何会改变系统状态的用户请求或后台任务（例如垃圾回收、设备故障后的重建等）都必须先写入多个 DBox 中的 SSD，在完成写入并确认持久化之前，不会向外发送完成响应。CNode 不会将写入请求或元数据更新缓存在 DRAM 中，甚至也不会使用带电保护的 NVRAM（非易失性内存）作为写缓存。</p> <p>虽然 NVRAM 常被视为“安全的缓存方式”，但它本质上只能防止断电导致的数据丢失，且一旦某两个关键节点同时故障，仍然有可能造成数据丢失，并需要系统执行复杂、容易出错的恢复流程来尝试还原 NVRAM 中的数据。</p> <p>这种设计带来的优势可以通过一个真实案例体现：几年前，美国波士顿地区的一个数据中心（为多所高校提供 HPC 和科研计算服务）发生了一次电力故障。在所有受影响的存储系统中，只有 VAST 集群能在恢复供电后自动恢复运行，而其他系统都需要管理员或厂商介入，手动执行一系列操作才能重新上线。</p> <p>CNode 与 DBox 中 SSD 之间通过 NVMe-oF 建立的超低延迟直连通道，也使得 CNode 无需再在 DRAM 中维护任何读缓存或元数据缓存。当 CNode 需要定位某个数据元素中第 3,451,098 个字节的位置时，它只需以微秒级延迟访问对应的元数据即可。由于不需要缓存机制，CNode 避免了跨节点维护缓存一致性所带来的系统复杂性和大量“东西向”（East-West）网络通信开销。</p> <p>基于容器化的架构，使 VAST Data Platform 能够以软件定义微服务的形式快速部署与弹性扩展，同时也奠定了高可用架构的基础——即使单个容器故障，也不会影响整个系统的运行。相比之下，传统系统为了更新软件版本通常需要重启整台服务器节点，而这过程可能耗费数分钟，尤其在 BIOS 执行内存自检（POST）时更是如此。而在 VAST 系统中，升级 VASTOS 时只需启动一个新的 VASTOS 容器，无需重启主机操作系统，极大地缩短了 VAST 服务器的离线时间，通常只需几秒钟即可完成。</p> <p>这种“无状态容器 + 快速热更新” 的组合，使得 VAST 系统能够在不中断服务的前提下完成几乎所有系统更新操作，包括 BIOS 升级、SSD 固件刷新乃至 SMB 这种有状态协议的更新，真正实现系统级的持续可用性和高可靠性。</p> <h3 id="ha-enclosures-dboxes">HA Enclosures (DBoxes)</h3> <p>所有 VAST 存储机箱（也称为 DBox，Data Box）都是基于 NVMe-oF（NVMe over Fabrics） 的高性能存储设备，用于通过超低延迟的 NVMe 网络结构将 SCM（存储级内存）和超大规模闪存 SSD 接入整个系统。这些连接可以基于以太网或 InfiniBand 实现。所有高可用（HA）机箱都采用完全冗余设计，不存在任何单点故障——从 NVMe 路由器（DNode）、SSD、网络接口卡（NIC），到风扇和电源模块，所有关键部件都具备双冗余能力，无论系统规模是 1 台机箱还是 1000 台 HA 机箱，都能确保集群的高可用性。</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2025-08-14-vast-data-platform/6.png" sizes="95vw"></source> <img src="/assets/img/2025-08-14-vast-data-platform/6.png" class="img-fluid rounded z-depth-0 mx-auto d-block" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p>从上方图示中可以看出，每个 HA Enclosure 内部配备两个 DNode（数据节点），它们负责将来自 NVMe Fabric 网络的请求通过自身的 PCIe 交换芯片路由到本机箱内的 SSD。</p> <p>由于网络端口到 SSD 之间没有任何单点故障，DBox 具备企业级的可靠性和超高吞吐能力。尽管表面上看，DBox 架构类似于传统的双控制器存储阵列，但实际上它在架构设计上存在几个根本性的区别：</p> <ul> <li>DNodes 并不承担任何集群的存储逻辑处理任务，因此即使平台新增功能，DNode 的 CPU 也不会成为系统瓶颈。</li> <li>与传统控制器不同，DNodes 不聚合 SSD，也不提供数据服务，它们仅需执行最基础的逻辑：将每块 SSD 显示到 NVMe Fabric 上，并在微秒级别内完成请求的路由。比如 VAST 的一款 DBox 设备 Ceres，就通过使用基于 ARM 架构的 DPU 作为 DNode，大幅降低了功耗。</li> <li>每个 DBox 内的两个 DNode 以主动-主动（Active-Active）方式运行。在正常情况下，每个 DNode 向 NVMe Fabric 网络呈现一半的 SSD；如果其中一个 DNode 下线，系统会通过 PCIe 交换芯片将原本属于故障节点的 SSD PCIe 通道重映射到剩余的 DNode，整个过程中仍然保持原子写入的一致性，确保数据安全性和连续性。</li> </ul> <h3 id="storage-class-memory">Storage Class Memory</h3> <p>“存储级内存”（Storage Class Memory，简称 SCM）是一类新型存储技术，性能与耐久性远高于传统 NAND 闪存，定位于 <strong>DRAM 与闪存之间的中间层</strong>，具备持久性、低延迟和高写入寿命等特性。</p> <p>在 VAST DataStore 中，SCM SSD 被用作 <strong>高性能写缓冲区和全局元数据存储层</strong>。选择 SCM 的主要原因是其极低的写入延迟和出色的耐用性，使 DASE 集群能够在无需依赖 DRAM 缓存的前提下，实现亚毫秒级别的写入响应，并显著延长超大规模闪存的寿命。</p> <p>每个 VAST 集群都部署有几十到数百 TB 的 SCM 空间，这为 DASE 架构带来了如下几个关键优势：</p> <ul> <li> <strong>优化写入延迟</strong> ：VAST Server 在将数据镜像写入超低延迟的 NVMe SCM 缓冲区后，即可向客户端确认写入成功。这个缓存区将应用层写入请求与底层耗时较高的数据服务操作（如闪存地址转换、数据压缩）隔离开来，同时屏蔽了超大规模闪存较高写延迟对应用的影响。</li> <li> <strong>减轻低耐久性闪存的压力</strong> ：数据可长时间停留在 SCM 写缓冲中。由于缓冲区容量远大于传统缓存，它显著降低了超大规模闪存因频繁写入和中间更新所造成的磨损。</li> <li> <strong>提升数据保护效率</strong> ：SCM 写缓冲具备足够容量来同时构建多个大规模且分布均衡的数据条带（stripe），并将其以最优的形式写入闪存，从而提升写入效率，使低成本 SSD 的寿命比传统企业级存储系统提高多达 20 倍。</li> <li> <strong>规避写放大问题</strong> ：借助 SCM，VAST 集群可以在数据写入确认之后、迁移到超大规模闪存之前执行压缩、去重等数据优化计算，避免了后处理（post-process）带来的写放大问题，从而提高存储系统的整体寿命与效率。</li> <li> <strong>全局数据压缩字典优化</strong> ：SCM 作为全局共享的元数据池，用于存储包括压缩字典在内的各种元数据信息。这使得系统可以应用更高效、更丰富的数据压缩策略，进一步降低基础设施成本，同时避免了传统去重存储设备中“每台服务器都需加载压缩索引至本地内存”的冗余问题。</li> </ul> <h3 id="hyperscale-flash">Hyperscale Flash</h3> <p>超大规模闪存（Hyperscale Flash）指的是像 Facebook、Google 和百度等超大规模互联网公司（Hyperscalers）所采用的一类 SSD，其核心目标是最大限度降低闪存的成本。由于这些公司构建存储系统的方式与传统企业级 SAN 阵列完全不同，所使用的闪存也在结构和性能设计上明显区别于企业级 SSD 和消费级 SSD。</p> <p>企业级 SSD 通常用于传统 SAN 系统，这类系统采用双控制器架构，需要 SSD 具备双端口、稳定低延迟的写入性能，因此这些 SSD 配备了昂贵的硬件，如双端口控制器、DRAM 缓存、电源故障保护电路，以及较高比例的预留空间（Overprovisioning）来提升耐用性，适应如 JEDEC 随机 4KB 写入等苛刻的测试标准。</p> <p>相比之下，超大规模公司构建的存储系统使用的是只能连接单端口的服务器，并且大多数数据是以大对象批量写入的形式进行，因此它们所用的 SSD 不需要双端口、DRAM 缓存，也不需要太多预留空间。超大规模闪存主要依赖当前最密集的存储单元——每单元存储 4 位的 QLC（四层单元）NAND，通过直接交付更大容量，实现闪存成本的极限压缩。</p> <p>每个闪存单元多存储一位，就意味着整体容量提升，同时制造成本基本不变，因此可显著降低单位 GB 的成本。然而，存储密度的提升也带来了显著的副作用——闪存的耐用性会随着存储位数的增加而显著下降。例如，第一代 SLC（单层单元）NAND 可承受约 100,000 次擦写，而 QLC 的耐久性则下降了近 100 倍。随着厂商推动下一代 PLC（五层单元）闪存，耐久性预计还会进一步下降。</p> <p>擦除闪存时需要施加高电压，这会在物理层面对闪存单元的绝缘层造成损伤。随着擦写次数的累积，绝缘层损伤越来越严重，最终会导致电子“泄漏”，穿透硅基绝缘体。以 QLC 为例，每个单元需要表示 16 种不同的电压等级（即 4 位数据），通常分布在 0 到 3 伏特之间。随着每个电压等级之间的差距变小，即使少量电子泄漏也可能引起数据错误（比如原本是 1 变成了 0），这就是高密度闪存耐久性变差的根本原因。</p> <p>VAST 的通用存储系统通过两种方式减少闪存磨损：</p> <ol> <li>采用创新的数据结构，能更好地贴合低成本超大规模 SSD 的内部物理结构，这在传统系统中从未尝试过；</li> <li>利用容量巨大的 SCM 写缓冲区来吸收写入压力，从而为写操作留出充足的时间与空间，避免直接磨损闪存。</li> </ol> <p>这两种机制的结合，使得 VAST 能够支持其闪存系统长达 10 年的使用寿命，显著提升了整体系统拥有成本的经济性与可持续性。</p> <h3 id="asymmetric-scaling">Asymmetric Scaling</h3> <p>传统的横向扩展（scale-out）架构通常将计算能力与存储容量绑定在一起，采用以下两种方式之一：要么是“共享无物”架构（shared-nothing），每个节点独立运行一个控制器；要么是“共享介质”架构（shared-media），每组节点共用一对控制器和一组磁盘。无论哪种方式，用户在扩展系统时都被迫同时购买计算资源和存储容量，而且只能在有限的节点配置范围内权衡成本、性能与数据中心资源之间的平衡，例如是选择少量高容量高性能节点，还是选择大量低容量低性能节点。</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2025-08-14-vast-data-platform/7.png" sizes="95vw"></source> <img src="/assets/img/2025-08-14-vast-data-platform/7.png" class="img-fluid rounded z-depth-0 mx-auto d-block" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p>而 DASE 架构彻底消除了这些限制，其核心设计理念是将计算能力与存储容量完全解耦：计算由 CNode（计算节点） 提供， 存储容量由 DBox（存储机箱） 提供，二者互不依赖。</p> <p>这带来了极大的灵活性：对于训练 AI 模型（这种负载涉及大量小文件随机访问）或运行复杂数据库查询的用户来说，他们可能会为每个 DBox 配置多达 12 个 CNode，以获得足够计算能力；而对于将 VAST 用作冷备份、归档等低活跃数据存储的用户来说，每个 DBox 可能只需不到一个 CNode 就能满足需求。</p> <p>当用户需要扩展容量时，只需新增 DBox，无需同时增加计算资源和功耗——这是传统纵向扩展（scale-up）存储系统中的经典特性，却早已被大多数横向扩展厂商所抛弃。虽然“只扩容”本身已经很经济、很实用，但传统存储厂商在需要提升某一容量下的计算能力时，通常只有两个选择：用“叉车式升级”，替换更强的新节点；增加节点数量，但使用更小容量的硬盘，从而提升每 PB 对应的 CPU 能力。</p> <p>VAST 则提供了更优雅的方式。 当用户发现：AI 引擎能从原本的“冷数据归档”中提取有价值的信息，新版本应用产生了大量的小文件随机访问负载，或者某个应用比预期更受欢迎、使用更广泛时， 他们可以仅通过增加 CNode 数量来扩展计算能力。</p> <p>系统会在这些新加入的 CNode 上自动重新平衡虚拟 IP 地址（VIPs）和计算任务分布，无需手动干预，确保整个集群始终保持最优的性能与资源利用率。</p> <h4 id="asymmetric-and-heterogeneous">Asymmetric and Heterogeneous</h4> <p>对于采用“共享无物”（shared-nothing）架构的用户来说，一旦厂商发布新一代节点产品，他们往往会面临棘手的升级困境。因为在这种架构中，一个存储池内的所有节点必须完全一致，举例来说，如果某客户当前有一个由 16 个已服役 3 年的节点组成的集群，想要扩展 50% 的容量，他面临两种选择：</p> <ul> <li>购买 8 个相同型号的旧节点，并为现有 16 个节点延长技术支持 <ul> <li>问题在于，这类延长支持通常总共最多提供 5~6 年服务周期，这意味着在未来 2~3 年内，客户需要整体更换所有 24 个节点</li> </ul> </li> <li>购买 5 个新型号节点（每个容量是旧型号的两倍）并新建一个存储池 <ul> <li>问题在于系统性能将取决于数据所在的具体存储池</li> <li>多池管理会增加系统复杂性</li> <li>小型新集群在资源利用率和扩展效率上都较差</li> </ul> </li> </ul> <p>情况会更加复杂的是，如果某些新功能（如内联去重、压缩）只能在新型号节点的更强处理器上运行，那旧节点便无法享受这些关键特性，进一步加剧了架构不一致带来的问题。</p> <p>VAST 提出的 DASE 架构是一种“非对称架构”，这并不仅仅是指客户可以通过灵活配置每个存储机箱（DBox）所搭配的 CNode（计算节点）数量，来自由调整每 PB 数据所分配的计算资源。</p> <p>“非对称”还意味着：</p> <ul> <li>在 DASE 系统中，运行 VAST CNode 容器的服务器、DBox 存储机箱以及内部使用的 SSD 都可以异构配置、灵活组合，</li> <li>系统可以在不同代、不同性能、不同规格的组件间协调工作，无需强制“整齐划一”。</li> </ul> <p>VAST 系统能够适配拥有不同核心数量或运行频率的 CNode（计算节点），其方式是将整个集群内的 CNode 视作一个统一的“计算资源池”，类似于操作系统如何在不同 CPU 核心间调度线程一样，VAST 系统会在各个 CNode 之间进行智能任务调度。</p> <p>当系统需要执行后台任务（如 SSD 故障后的数据重建、或将数据从 SCM 写缓冲迁移至超大规模闪存）时，这些任务会被分配给当前利用率最低的服务器。处理能力更强的 CNode 可以完成更多工作，因此系统会自动为其分配更多任务，实现负载均衡与性能最优配比。</p> <p>在存储资源管理上，DASE 系统也采用了类似的思路，将集群中的 SSD（无论是 SCM 还是超大规模闪存）统一管理为一个可用容量池。每个 CNode 都可以直接访问集群内的任意 SSD，同时 DNode 提供了到这些 SSD 的冗余访问路径，因此系统可将 SSD 视作彼此独立的资源和故障域。</p> <p>例如，当一个 CNode 需要申请 SCM 写缓冲区时，它会优先选择两个：空闲写入缓冲空间最多的 SCM SSD，彼此物理距离最远的两块 SSD，并确保这两块 SSD 通过不同的 DNode 连接至 Fabric 网络，若系统中有多个 DBox，则还要分布在不同 DBox 中。</p> <p>同样地，当系统需要在超大规模闪存中分配一个纠删码（erasure-code）条带时，也会优先选择当前可用空间最多、耐用性最好的 SSD，从而实现条带在 SSD 之间的最优分布。</p> <p>由于系统是根据每块 SSD 的剩余容量和剩余寿命来分配任务的，因此在一个集群中，新加入或容量更大的 SSD 会比旧设备承担更多的数据写入和纠删码条带分配任务。直到整个集群中各块 SSD 在磨损程度和空间利用率方面趋于一致，系统才会逐步实现负载均衡。</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2025-08-14-vast-data-platform/8.png" sizes="95vw"></source> <img src="/assets/img/2025-08-14-vast-data-platform/8.png" class="img-fluid rounded z-depth-0 mx-auto d-block" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p>在 VAST 架构下，当客户的集群需要更多计算能力时，不需要全面升级成新一代、更高性能的节点，而只需按需增加几个新的 CNode（计算节点）即可。这种方式灵活、高效，避免了大规模更换设备带来的成本和复杂性。</p> <h3 id="server-pooling">Server Pooling</h3> <p>在 DASE 架构中，VAST Server（即 CNode）承担着平台计算核心的角色，负责运行 VAST Data Platform 的各种服务，并负责将整个集群与外部网络进行连接。VAST 用户可以将集群中的 VAST Server 划分为多个“资源池”，这种做法有多种应用场景：</p> <p><strong>1. 支持不同类型的网络接入技术</strong><br> 例如，用户可以将一部分 CNode 配置为带有 Infiniband 网络卡的资源池，用于高性能计算（HPC）集群的数据访问；而另一部分 CNode 配置为配有 100 Gbps 以太网网卡的资源池，用于企业其余基础设施的网络接入。这样就能实现同一个 VAST 存储集群通过不同网络协议支持不同类型的工作负载。</p> <p><strong>2. 实现网络隔离与多租户控制</strong><br> VAST 管理员可以根据 IP 地址范围限制不同租户或用户对特定视图（View，即多协议共享目录、导出路径或对象桶）的访问权限。通过对不同 CNode 资源池进行划分，可以实现基于位置、用户或业务域的访问隔离，从而提升数据安全性和多租户管理能力。</p> <p><strong>3. 为不同用户、应用或服务提供专属性能</strong><br> 通过将某些 CNode 专门划分给特定应用、用户组或服务使用，VAST 支持将计算与网络资源“专属化”分配，作为一种积极的服务质量（QoS）保障机制。这种方式可以确保关键业务在高负载环境下也能获得稳定、可预测的性能。</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2025-08-14-vast-data-platform/9.png" sizes="95vw"></source> <img src="/assets/img/2025-08-14-vast-data-platform/9.png" class="img-fluid rounded z-depth-0 mx-auto d-block" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p>上图所示的 VAST 集群被划分为三个服务器资源池：一个用于运行批处理（更准确地说，是持续型）应用的资源池，一个为交互式用户提供专属性能的资源池，以及一个用于备份应用的资源池。这样的划分确保交互式用户始终拥有足够的性能体验，同时批处理和备份任务彼此之间不会产生干扰。</p> <p>对于更复杂的使用场景，比如动画工作室这样的用户，还可以通过脚本或 VAST Data Engine 的自动化函数，在不同资源池之间动态迁移 CNode。比如在白天将更多计算节点分配给对性能要求较高的美术师使用，等到夜晚美术师下班后，再将这些 CNode 重新分配到渲染资源池，最大化渲染性能利用率。</p> <p>CNode 资源池机制本身就是一种积极型 QoS（服务质量保障）机制，通过控制分配给每个资源池的服务器数量来保证各类任务的性能需求。此外，VAST DataStore 还支持声明式 QoS 策略，可参考本文稍后 “QoS Silences Noisy Neighbors”（QoS 消除“吵闹邻居”效应）一节中对 VAST Element Store 的进一步说明。</p> <p>每个服务器资源池都会分配一组 VIP（虚拟 IP 地址），这些 VIP 会分布在池内的各个 CNode 上。如果某个 CNode 下线，它所负责的 VIP 会自动重新分配给该资源池中其余的节点。VAST 建议每个资源池配置的 VIP 数应为 CNode 数量的 2 到 4 倍，这样一来，即使某个节点出现故障，其负载也可以被多个其他节点共同接管，从而确保服务稳定性。</p> <p>此外，每个 CNode 可以同时隶属于多个资源池，这意味着它可以在处理用户请求的同时，也参与 DASE 集群间的数据复制任务，进一步提升系统的灵活性和资源利用效率。</p> <h3 id="networking-in-dase">Networking in DASE</h3> <p>DASE 集群包含四个主要的逻辑网络，分别承担不同的通信任务：</p> <p><strong>1. NVMe Fabric（后端网络）</strong><br> 这是连接 CNode（计算节点）与 DNode（存储节点）的内部高速网络。VAST 集群使用基于 RDMA 的 NVMe-oF 协议（NVMe over Fabrics），通常部署在 100 Gbps 的以太网或 InfiniBand 上，其中以太网是默认选项。这个网络是整个系统的数据传输主干，负责在计算与存储之间实现极低延迟的高速通信。</p> <p><strong>2. Host Network（前端网络）</strong><br> 这是集群对外服务的网络，用于承载来自客户端的文件访问请求、对象存储请求或数据库查询请求。这部分网络负责连接客户端主机与 CNode，是用户与 VAST 集群之间的主要交互通道。</p> <p><strong>3. Management Network（管理网络）</strong><br> 该网络负责集群的管理通信，包括 DNS 查询、身份验证、管理指令下发等。它通常用于 VAST 管理员对系统的监控、配置和维护操作。</p> <p><strong>4. IPMI Network（硬件管理网络）</strong><br> 用于对集群中的物理硬件进行底层管理与监控，比如远程控制、硬件健康状态监测、电源管理等，确保系统在底层硬件层面具备可控性和高可用性。</p> <p>根据不同的部署需求，VAST 客户可以选择使用独立物理端口、VLAN 虚拟局域网或两者组合的方式来实现上述逻辑网络，以满足网络设计规范和安全策略的要求。</p> <p>其中最关键的设计决策之一，是<strong>如何将 DASE 集群接入客户的数据中心网络，以提供客户端访问能力</strong>。这不仅影响性能与安全，也关系到整个系统的可扩展性与维护效率。</p> <h4 id="connect-via-switch">Connect via Switch</h4> <p>“通过交换机连接（Connect via Switch）”模式，是在每个 DASE 集群自带的 NVMe Fabric 交换机上，将 NVMe 后端网络与前端主机网络分别运行在两个不同的 VLAN 上。这两种网络共享同一套交换基础设施。客户的数据中心主机网络通过交换机与 DASE 集群进行连接，方式是将 Fabric 交换机通过 MLAG（多链路聚合）连接至客户核心交换机，如图中绿色线路所示。</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2025-08-14-vast-data-platform/10.png" sizes="95vw"></source> <img src="/assets/img/2025-08-14-vast-data-platform/10.png" class="img-fluid rounded z-depth-0 mx-auto d-block" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p>在此模式下，每个 CNode 配备一张 100 Gbps 的网络接口卡（NIC）。通过一根分线电缆将这张卡拆分为两个 50 Gbps 的连接口，分别连接到两个 Fabric 交换机中。每条 50 Gbps 连接同时承载两个 VLAN：一个用于 NVMe 后端网络，另一个用于主机数据流量。</p> <p>这种连接方式具有以下优点：</p> <ul> <li>每个 CNode 只需配置一张 RDMA 网络接口卡（RNIC），降低硬件复杂度和成本</li> <li>所有网络流量通过少量 100 Gbps 链路进行汇聚，并通过 MLAG 实现高可用，这样可显著减少对客户主机交换机端口数量的需求</li> </ul> <p>但如果这种方式是“完美方案”，就不会存在其他替代选项。它也有一些限制和不足：</p> <ul> <li>主机网络必须使用与 Fabric 网络相同的网络类型与协议</li> <li>如果集群使用 Infiniband 构建 NVMe Fabric，则只能支持 Infiniband 主机接入，限制较大</li> <li>在 100 Gbps Fabric 中使用 40、25、10 Gbps 的以太网接入时，连接成本较高且不灵活</li> <li>整个集群只能配置一个物理主机网络，不适合有多个前端网络需求的复杂部署环境</li> </ul> <h4 id="connect-via-cnode">Connect via CNode</h4> <p>通过 NVMe Fabric 交换机将 DASE 集群接入客户网络是一种简单、端口使用最少的方式。但正如我们在前文关于“服务器资源池”的部分中所讨论的，有些客户需要在<strong>客户端接入方式或多租户隔离上拥有更高的灵活性与控制权</strong>，这时单一的交换机连接方案就可能显得不够用了。</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2025-08-14-vast-data-platform/11.png" sizes="95vw"></source> <img src="/assets/img/2025-08-14-vast-data-platform/11.png" class="img-fluid rounded z-depth-0 mx-auto d-block" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p>当 VAST 客户需要将来自多个不同网络、采用不同技术或有不同安全需求的客户端接入同一个 DASE 集群时，可以为 CNode 安装第二张网络接口卡（NIC），这张卡直接连接到该 CNode 所服务的特定网络，从而实现与多个网络的并行连接。</p> <p>“通过 CNode 连接（Connect via CNode）”的优点：</p> <ul> <li>支持通过不同技术协议接入 DASE 集群： <ul> <li>配有 Infiniband 网卡的 CNode 可以服务于 Infiniband 客户端</li> <li>配有 Ethernet 网卡的 CNode 可以服务于以太网客户端</li> <li>或通过 Fabric 交换机为 Ethernet 客户端提供接入</li> </ul> </li> <li>支持接入更高速的前沿网络技术，如 200 Gbps 以太网</li> <li>能够连接多个安全隔离区域（Security Zones），无需配置跨网络路由，简化安全策略管理</li> </ul> <p>但也存在一些缺点：</p> <ul> <li>需要额外的网络接口卡、交换机端口、IP 地址等资源，增加一定的部署与运维成本</li> </ul> <p>正如上文所述，VAST 的架构允许客户灵活混用“通过交换机连接（Connect via Switch）”和“通过 CNode 连接（Connect via CNode）”两种模式。例如，某客户拥有少量 Infiniband 主机，可以仅为部分 CNode 安装 IB 网卡以接入这些主机；而其他以太网客户端则仍通过共享的 Ethernet Fabric 交换机接入集群，从而在满足连接需求的同时，最大限度地减少交换机端口资源的使用。</p> <h4 id="leaf-spine-for-large-clusters">Leaf-Spine for Large Clusters</h4> <p>当 DASE 集群的规模扩大到需要的 NVMe fabric 连接数量超过一对 64 端口交换机所能提供的上限时，原本作为集群核心的一对 Fabric 交换机将演变为一个更大规模的 <strong>Leaf-Spine 网络架构</strong>。</p> <p>在这种扩展架构中，CBox（一个多服务器设备，在单一机箱中运行多个 CNode）和 DBox 仍然连接到一对交换机，但这些交换机不再是集群的“核心”，而是作为 <strong>“叶子（Leaf）”交换机</strong>，并通过冗余连接对接到两台 <strong>Spine（主干）交换机</strong>上。而集群中其他机架顶部的 Leaf 交换机也以同样方式接入 Spine 层，形成完整的 Leaf-Spine 拓扑。</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2025-08-14-vast-data-platform/12.png" sizes="95vw"></source> <img src="/assets/img/2025-08-14-vast-data-platform/12.png" class="img-fluid rounded z-depth-0 mx-auto d-block" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p>这种 Leaf-Spine 网络结构的优势在于：</p> <ul> <li>支持 DASE 集群 横向扩展至超过 100 台设备（appliances）</li> <li>如果使用高端口数的 director 级 Spine 交换机，可进一步提升扩展上限</li> <li>具备更高的带宽聚合能力和更低的网络延迟，适配 NVMe-oF 对网络性能的极高要求</li> <li>有助于保持 每个 CNode 到任意 DBox 之间都能实现一致的网络性能，即所谓“扁平化网络”</li> </ul> <h2 id="scale-out-beyond-shared-nothing">Scale-Out Beyond Shared-Nothing</h2> <p>在过去十多年里，存储行业一直深信“无共享（shared-nothing）”存储架构是实现存储规模扩展与成本节省的最佳方式。自从 Google 于 2003 年发布其文件系统架构白皮书之后，几乎所有类型的存储系统架构都将“无共享”模式作为标配，包括超融合存储、可扩展文件存储、对象存储、数据仓库系统等。</p> <p>然而，十多年过去了，“无共享”架构所依赖的一些基本前提，如今已不再成立，主要原因如下：</p> <ul> <li>无共享系统最初设计的前提，是将磁盘与处理器（CPU）物理共置，因为当时网络速度远慢于本地存储。然而随着 NVMe over Fabrics（NVMe-oF）的出现，现在即便在远程访问 SSD 和 SCM 时，也能实现高性能，不再需要将 CPU 与存储设备强绑定。</li> <li>无共享架构迫使用户在扩展计算能力和存储容量时必须“打包”进行，导致基础设施扩展缺乏灵活性。相比之下，如果能够根据数据集对访问速度的需求单独扩展 CPU，将更为高效灵活。</li> <li>无共享系统限制了存储效率。因为每个节点都“拥有”一部分存储介质，为了容错，就必须在节点之间进行纠删码（erasure coding），这限制了条带（stripe）的宽度与切片（shard）效率；同时还需在多个节点复制数据缩减的元数据，影响了数据压缩与去重的效率。而在“全共享（shared-everything）”架构中，没有任何一台机器专属某些 SSD，因此可以构建更宽、更高效的 RAID 条带结构，并集中管理全局数据缩减元数据，提升整体存储效率。</li> <li>随着容器成为部署应用程序的主流方式，这种基于微服务的架构模式也受益于容器本身的“无状态”特性。在数据本地性不再构成瓶颈的前提下，存储服务可以轻松在可组合基础设施中快速部署与弹性扩展。</li> </ul> <h3 id="the-advantages-of-a-stateless-design">The Advantages of a Stateless Design</h3> <p>当一台 VAST 服务器（称为 CNode）接收到读取请求时，该 CNode 会从共享的存储级内存（SCM）中读取 VAST DataStore 的持久化元数据，以定位被请求的数据具体存储在哪些位置。接着，它会直接从超大规模闪存（hyperscale flash）中读取该数据（如果数据尚未从写入缓冲区迁移，则直接从 SCM 读取），并将数据返回给发起请求的客户端。对于写入请求，VAST 服务器会将数据和元数据直接写入多块 SSD 中，然后再向客户端返回写入成功的响应。</p> <p>通过在超低延迟的网络结构中直接访问共享设备，VAST 服务器无需彼此通信即可完成 I/O 请求的处理——在读写路径中，任何机器都不需要与其他机器进行同步通信。“全共享”（Shared-Everything）架构让性能扩展变得非常简单，只需添加更多的 CPU 即可线性提升性能，从而突破传统“无共享”架构在扩展过程中常见的收益递减问题。用户可以构建由数千台 VAST 服务器组成的大型集群，实现极致的整体性能。VAST 集群规模的主要限制因素是客户部署的网络结构的容量。</p> <p>将系统所有元数据存储在通过超低延迟网络连接的共享 SSD 上，意味着 CNode 无需缓存元数据，因此也不需要在服务器之间维持元数据缓存一致性。而且，因为所有数据在写入时都已同步写入持久性的 SCM SSD 中（而不是先缓存在易失性 DRAM 中），就不再需要传统写缓存常用的断电保护硬件。这种做法将完全非易失性存储介质与事务性存储语义相结合，从而确保 VAST Element Store 的更新始终具备一致性和持久性。</p> <p>DASE 架构也彻底消除了传统存储架构中“存储设备必须归某台控制器节点或其冗余对控制”的需求。由于集群中所有 SCM 和超大规模闪存 SSD 都对所有 CNode 共享，任意一台 CNode 都可以从头到尾独立完成请求的处理。这意味着哪怕一整个 VAST 集群中只剩下一台服务器可用，集群依然可以保持完整运行、继续提供所有的数据服务。例如，如果一个集群由 100 台服务器组成，即使其中 99 台失效，剩下的那一台仍可支撑整个系统 100% 正常在线运行。</p> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/vast-data-store/">White Paper: The VAST DataStore</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/tpm-based-security/">Key Management in TPM based Security</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/attest-grub-boot/">virtCCA: Measured Boot and Attestation in Grub Boot</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/tdx-measure-boot/">Intel TDX: Measured Boot and Attestation in Grub Boot</a> </li> </div> </div> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2025 Haocheng Ma. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script defer src="/assets/js/bootstrap-toc.min.js?c82ff4de8b0955d6ff14f5b05eed7eb6"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>addBackToTop();</script> <script type="module" src="/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script>let searchTheme=determineComputedTheme();const ninjaKeys=document.querySelector("ninja-keys");"dark"===searchTheme?ninjaKeys.classList.add("dark"):ninjaKeys.classList.remove("dark");const openSearchModal=()=>{const e=$("#navbarNav");e.hasClass("show")&&e.collapse("hide"),ninjaKeys.open()};</script> <script>const ninja=document.querySelector("ninja-keys");ninja.data=[{id:"nav-about",title:"about",section:"Navigation",handler:()=>{window.location.href="/"}},{id:"nav-blog",title:"blog",description:"",section:"Navigation",handler:()=>{window.location.href="/blog/"}},{id:"nav-publications",title:"publications",description:"",section:"Navigation",handler:()=>{window.location.href="/publications/"}},{id:"post-white-paper-the-vast-datastore",title:"White Paper: The VAST DataStore",description:"Translated version of VAST&#39;s white paper (part 2).",section:"Posts",handler:()=>{window.location.href="/blog/2025/vast-data-store/"}},{id:"post-white-paper-the-vast-data-platform",title:"White Paper: The VAST Data Platform",description:"Translated version of VAST&#39;s white paper (part 1).",section:"Posts",handler:()=>{window.location.href="/blog/2025/vast-data-platform/"}},{id:"post-key-management-in-tpm-based-security",title:"Key Management in TPM based Security",description:"TPMs are ridiculously complex.",section:"Posts",handler:()=>{window.location.href="/blog/2025/tpm-based-security/"}},{id:"post-virtcca-measured-boot-and-attestation-in-grub-boot",title:"virtCCA: Measured Boot and Attestation in Grub Boot",description:"Our solution to establish trust for confidential VMs booting via firmware.",section:"Posts",handler:()=>{window.location.href="/blog/2025/attest-grub-boot/"}},{id:"post-intel-tdx-measured-boot-and-attestation-in-grub-boot",title:"Intel TDX: Measured Boot and Attestation in Grub Boot",description:"How to build a trusted chain when launch TD guest using grub boot.",section:"Posts",handler:()=>{window.location.href="/blog/2025/tdx-measure-boot/"}},{id:"socials-email",title:"Send email",section:"Socials",handler:()=>{window.open("mailto:%61%6E%64%72%65%77%6D%61%68%63@%67%6D%61%69%6C.%63%6F%6D","_blank")}},{id:"socials-orcid",title:"ORCID",section:"Socials",handler:()=>{window.open("https://orcid.org/0000-0002-7118-9379","_blank")}},{id:"socials-google-scholar",title:"Google Scholar",section:"Socials",handler:()=>{window.open("https://scholar.google.com/citations?user=cdWqgwUAAAAJ","_blank")}},{id:"socials-github",title:"GitHub",section:"Socials",handler:()=>{window.open("https://github.com/haocheng-ma","_blank")}},{id:"light-theme",title:"Change theme to light",description:"Change the theme of the site to Light",section:"Theme",handler:()=>{setThemeSetting("light")}},{id:"dark-theme",title:"Change theme to dark",description:"Change the theme of the site to Dark",section:"Theme",handler:()=>{setThemeSetting("dark")}},{id:"system-theme",title:"Use system default theme",description:"Change the theme of the site to System Default",section:"Theme",handler:()=>{setThemeSetting("system")}}];</script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>