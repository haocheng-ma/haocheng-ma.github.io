<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta name="google-site-verification" content="IZHz75ntcIC4eGlb8HT7ZmeXprRk-iWg8hQMbMEmd84"> <meta http-equiv="Permissions-Policy" content="interest-cohort=()"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Measured boot in Intel TDX's grub boot | Haocheng Ma </title> <meta name="author" content="Haocheng Ma"> <meta name="description" content="How to build a trusted chain when launch TD guest using grub boot."> <meta name="keywords" content="haocheng ma, academic-website, portfolio-website"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css2?family=Lato:ital,wght@0,400;0,700;1,400;1,700&amp;family=Mulish:ital,wght@0,200..1000;1,200..1000&amp;family=Nunito:ital,wght@0,200..1000;1,200..1000&amp;family=Open+Sans:ital,wght@0,300..800;1,300..800&amp;family=Roboto:ital,wght@0,100..900;1,100..900&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link defer href="/assets/css/bootstrap-toc.min.css?6f5af0bb9aab25d79b2448143cbeaa88" rel="stylesheet"> <link rel="shortcut icon" href="/assets/img/icon_pic.ico?201b24740f59dd40b09d1d7ec803eeaa"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="haocheng-ma.github.io/blog/2025/tdx-measure-boot/"> <script src="/assets/js/theme.js?9a0c749ec5240d9cda97bc72359a72c0"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>initTheme();</script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Haocheng</span> Ma </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="row"> <div class="col-sm-3"> <nav id="toc-sidebar" class="sticky-top"></nav> </div> <div class="col-sm-9"> <div class="post"> <header class="post-header"> <h1 class="post-title">Measured boot in Intel TDX's grub boot</h1> <p class="post-meta"> Created in January 12, 2025 </p> <p class="post-tags"> <a href="/blog/2025"> <i class="fa-solid fa-calendar fa-sm"></i> 2025 </a>   ·   <a href="/blog/tag/tdx"> <i class="fa-solid fa-hashtag fa-sm"></i> tdx</a>   <a href="/blog/tag/measurement"> <i class="fa-solid fa-hashtag fa-sm"></i> measurement</a>   <a href="/blog/tag/attestation"> <i class="fa-solid fa-hashtag fa-sm"></i> attestation</a>   ·   <a href="/blog/category/cc"> <i class="fa-solid fa-tag fa-sm"></i> cc</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <p>Intel Trust Domain Extension (TDX) allows people to deploy hardware-isolated virtual machines (VMs) called trust domains (TDs). A TD VM is isolated from the virtual machine manager (VMM), hypervisor, and other non-TD software on the host platform. The entire memory contents of a TD is encrypted using a multiple-key encryption method. Intel TDX excludes the host platform from the TD’s trusted computing base (TCB).</p> <p>Intel TDX workloads are primarily VM images that tenants want to run as TDs in a cloud environment. Special Open Virtual Machine Firmware (OVMF) supplied by the CSP is required to run a VM in a TD, such as TDX Virtual Firmware (TDVF). TDVF is an EDK2 based project to enable UEFI support for TDX based Virtual Machines. It provides the capability to launch a TD. TDVF allows two configurations with different features, please see <a href="#jumpA">Appendix: TDVF Configurations</a> from <a href="https://github.com/tianocore/edk2/blob/master/OvmfPkg/IntelTdx/README.md" rel="external nofollow noopener" target="_blank">Configurations and Features</a>.</p> <p>During TD boot, the hash-chained measurement on TCB will be extended to some secure registers (also known as measured boot). The values from several secure registers construct to a report and are finally signed to be a quote by an attestation key. Before providing data to the workload, a relying party uses attestation to verify that the software is running within a TD on a genuine Intel TDX system and at the specified security level.</p> <p><em>NOTE: Here TCB refers to all of a system’s hardware, firmware, and software components that provide a secure environment, including hardware information such as CPU, SEAM firmware, and guest components such as OVMF, bootloader (shim/grub), and kernel.</em></p> <p><strong>The above is a brief description of Intel TDX. In the upcoming series of articles, we will focus on TD’s measured boot and attestation.</strong></p> <h2 id="td-boot-types">TD Boot Types</h2> <p>The following diagram illustrates the TD boot type and boot process.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2025-01-12-tdx-measure-boot/td_guest_boot_process.png" sizes="95vw"></source> <img src="/assets/img/2025-01-12-tdx-measure-boot/td_guest_boot_process.png" class="img-fluid rounded z-depth-0 mx-auto d-block" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <div class="caption">     Figure 1. TD Guest Boot Process </div> <p><strong>Direct boot</strong> is a boot process where the system boots directly into the OS without an intermediate boot loader. It can also be referred to as direct kernel boot with firmware, in which firmware loads kernel and initrd through the FwCfg device provided by Qemu.</p> <p><strong>Grub boot</strong> involves using the Grub bootloader, which provides advanced boot menu options, allowing you to select different operating systems and customize boot configurations. It can also be referred to as firmware-only boot, in which firmware launches a bootloader from a disk image.</p> <p>The detailed boot flow for different TD boot methods can be found in Figure 2.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2025-01-12-tdx-measure-boot/detailed_flow_for_different_td_boot.png" sizes="95vw"></source> <img src="/assets/img/2025-01-12-tdx-measure-boot/detailed_flow_for_different_td_boot.png" class="img-fluid rounded z-depth-0 mx-auto d-block" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <div class="caption">     Figure 2. Detailed Flow for Different TD Boot </div> <p><strong>Today we will be diving into Measured Boot in Grub Boot.</strong></p> <p>In the virtual firmware, i.e., OVMF, the image handler <code class="language-plaintext highlighter-rouge">DxeTpmMeasureBootHandler</code> will be triggered when loading EFI image via <code class="language-plaintext highlighter-rouge">CoreLoadImageCommon()</code>. The <code class="language-plaintext highlighter-rouge">DxeTpmMeasureBootHandler</code> measures the objects like FV, QEMU CFG, VMM Hob, Variable into measurement registers (MRs). Then in boot loader ShimX64.efi, <code class="language-plaintext highlighter-rouge">TpmMeasureVariable()</code> measures the secure boot’s certificates into MRs. If secure boot is not enabled, ShimX64.efi may be absent from the VM image. Finally, boot loader GrubX64.efi measures kernel binary and cmdline, initrd binary, and grub’s module into MRs.</p> <p>Yes, the process here is draws on the TCG trusted boot chain. The difference is that it does not trust the hypervisor and avoids using mutable non-volatile storage (causing MR change). Futhermore, its trust chain can trace back to the TDX enable hardware.</p> <h2 id="uefi-boot-sequence">UEFI Boot Sequence</h2> <p>UEFI allows the extension of platform firmware by loading UEFI driver and UEFI application images. When UEFI drivers and UEFI applications are loaded they have access to all UEFI-defined runtime and boot services. See the Booting Sequence Figure 3 below.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2025-01-12-tdx-measure-boot/uefi_booting_sequence.png" sizes="95vw"></source> <img src="/assets/img/2025-01-12-tdx-measure-boot/uefi_booting_sequence.png" class="img-fluid rounded z-depth-0 mx-auto d-block" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <div class="caption">     Figure 3. UEFI Booting Sequence </div> <p>UEFI allows the consolidation of boot menus from the OS loader and platform firmware into a single platform firmware menu. These platform firmware menus will allow the selection of any UEFI OS loader from any partition on any boot medium that is supported by UEFI boot services.</p> <p>The OS loader operates as a UEFI application, utilizing UEFI services via Boot Services (BS) and Runtime Services (RT). It then invokes <code class="language-plaintext highlighter-rouge">ExitBootServices()</code> to terminate BS and release its resources, with only RT remaining available to the OS.</p> <p>A detailed introduction to UEFI boot phases refers to <a href="#jumpB">Appendix: UEFI Boot Phase</a> from <a href="https://secret.club/2020/05/26/introduction-to-uefi-part-1.html#uefi-boot-phases" rel="external nofollow noopener" target="_blank">UEFI boot phases</a>.</p> <h2 id="measured-boot-component">Measured Boot Component</h2> <p>See Figure 4, the pre-boot environment before the kernel includes the TDVF/OVMF phase and the bootloader phase (shim and grub). The whole boot chain will be measured into Runtime Measurement Register (RTMR) via <code class="language-plaintext highlighter-rouge">EFI_CC_MEASUREMENT_PROTOCOL</code>.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2025-01-12-tdx-measure-boot/td_measurement_process.png" sizes="95vw"></source> <img src="/assets/img/2025-01-12-tdx-measure-boot/td_measurement_process.png" class="img-fluid rounded z-depth-0 mx-auto d-block" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <div class="caption">     Figure 4. TD Measurement Process </div> <p>Similar to the TCG event log, <code class="language-plaintext highlighter-rouge">EFI_CC_MEASUREMENT_PROTOCOL</code> logs the events into confidential computing event log (CCEL) ACPI table and the measurement hash is extended to the corresponding RTMR register. The event logs in CCEL table can be replayed within a TD guest to verify the RTMR value.</p> <p>The Measured Boot Component in EDK2 is as follows.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2025-01-12-tdx-measure-boot/measured_boot_component_in_edk2.png" sizes="95vw"></source> <img src="/assets/img/2025-01-12-tdx-measure-boot/measured_boot_component_in_edk2.png" class="img-fluid rounded z-depth-0 mx-auto d-block" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <div class="caption">     Figure 5. Measured Boot Component in EDK2 </div> <p>The <a href="https://github.com/tianocore/edk2/tree/master/OvmfPkg/IntelTdx/TdxHelperLib" rel="external nofollow noopener" target="_blank"><code class="language-plaintext highlighter-rouge">SecTdxHelperLib</code></a> library provides measurement functions in SEC phase. The <a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/Protocol/CcMeasurement.h" rel="external nofollow noopener" target="_blank"><code class="language-plaintext highlighter-rouge">EFI_CC_MEASUREMENT_PROTOCOL</code></a> protocol abstracts the confidential computing (CC) measurement operation in UEFI guest environment. The <a href="https://github.com/tianocore/edk2/blob/master/OvmfPkg/Tcg/TdTcg2Dxe/TdTcg2Dxe.c" rel="external nofollow noopener" target="_blank">TdTcg2Dxe.c</a> DXE driver handles the DXE phase measurement. The <a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Library/DxeTpm2MeasureBootLib" rel="external nofollow noopener" target="_blank"><code class="language-plaintext highlighter-rouge">DxeTpm2MeasureBootLib</code></a> library handles the PE image measurements and GPT measurement. All event type definition can be found at <a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" rel="external nofollow noopener" target="_blank"><code class="language-plaintext highlighter-rouge">UefiTcgPlatform.h</code></a>.</p> <p>Here we give a description of <code class="language-plaintext highlighter-rouge">EFI_CC_MEASUREMENT_PROTOCOL</code> from <a href="https://uefi.org/specs/UEFI/2.10/38_Confidential_Computing.html#" rel="external nofollow noopener" target="_blank">Confidential Computing in UEFI Specification</a>.</p> <p>If a virtual firmware with CC capability supports measurement, the virtual firmware should produce <code class="language-plaintext highlighter-rouge">EFI_CC_MEASUREMENT_PROTOCOL</code> with new GUID <code class="language-plaintext highlighter-rouge">EFI_CC_MEASUREMENT_PROTOCOL_GUID</code> to report event log and provide hash capability.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define EFI_CC_MEASUREMENT_PROTOCOL_GUID  \
  { 0x96751a3d, 0x72f4, 0x41a6, { 0xa7, 0x94, 0xed, 0x5d, 0x0e, 0x67, 0xae, 0x6b }}
</span><span class="k">extern</span> <span class="n">EFI_GUID</span>  <span class="n">gEfiCcMeasurementProtocolGuid</span><span class="p">;</span>

<span class="cp"># Protocol Interface Structure
</span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_EFI_CC_MEASUREMENT_PROTOCOL</span> <span class="p">{</span>
  <span class="n">EFI_CC_GET_CAPABILITY</span>          <span class="n">GetCapability</span><span class="p">;</span>
  <span class="n">EFI_CC_GET_EVENT_LOG</span>           <span class="n">GetEventLog</span><span class="p">;</span>
  <span class="n">EFI_CC_HASH_LOG_EXTEND_EVENT</span>   <span class="n">HashLogExtendEvent</span><span class="p">;</span>
  <span class="n">EFI_CC_MAP_PCR_TO_MR_INDEX</span>     <span class="n">MapPcrToMrIndex</span><span class="p">;</span>
<span class="p">}</span> <span class="n">EFI_CC_MEASUREMENT_PROTOCOL</span><span class="p">;</span>
</code></pre></div></div> <p>This protocol defines four parameters in the above interface structure, including:</p> <ul> <li>GetCapability provides protocol capability information and state information.</li> <li>GetEventLog allows a caller to retrieve the address of a given event log and its last entry.</li> <li>HashLogExtendEvent provides callers with an opportunity to extend and optionally log events without requiring knowledge of actual CC command.</li> <li>MapPcrToMrIndex provides callers information on TPM PCR to CC MR mapping.</li> </ul> <p><strong>Mapping for Intel TDX</strong></p> <p>The following table shows the TPM Platform Configuration Register (PCR) index mapping and CC event log MR index interpretation for Intel TDX, where MRTD means Trust Domain Measurement Register and RTMR means Runtime Measurement Register. There certainly are fewer TD MRs than TPM PCRs. They are typically mapped as below:</p> <table> <thead> <tr> <th>TPM PCR Index</th> <th>Typical Usage of Measurement Registers</th> <th>TDX MR Index</th> </tr> </thead> <tbody> <tr> <td>0</td> <td>FirmwareCode (BFV, including init page table)</td> <td>MRTD</td> </tr> <tr> <td>1</td> <td>FirmwareData (CFV, TD Hob, ACPI Table, Boot Variable)</td> <td>RTMR[0]</td> </tr> <tr> <td>2</td> <td>Option ROM code</td> <td>RTMR[1]</td> </tr> <tr> <td>3</td> <td>Option ROM code</td> <td>RTMR[1]</td> </tr> <tr> <td>4</td> <td>OS loader code</td> <td>RTMR[1]</td> </tr> <tr> <td>5</td> <td>GUID partition table (GPT)</td> <td>RTMR[1]</td> </tr> <tr> <td>6</td> <td>N/A</td> <td>N/A</td> </tr> <tr> <td>7</td> <td>Secure Boot Configuration</td> <td>RTMR[0]</td> </tr> <tr> <td>8~15</td> <td>TD OS measurement</td> <td>RTMR[2]</td> </tr> </tbody> </table> <p><em>NOTE: RTMR[3] is reserved for special usage, such as virtual TPM. Users have the flexibility to utilize RTMR[3] if it is not required for these specialized purposes.</em></p> <p>The typical usage of MRTD and RTMR is shown below, more detailes could be found in <a href="https://cdrdv2.intel.com/v1/dl/getContent/733585" rel="external nofollow noopener" target="_blank">8.1 Measurement Register Usage in TD</a>.</p> <ul> <li>MRTD is for the TDVF code (match PCR[0]).</li> <li>RTMR[0] is for the TDVF configuration (match PCR[1,7]). The usage should follow TCG Platform Firmware Profile (PFP) specification.</li> <li>RTMR[1] is for the TDVF loaded component, such as OS loader (match PCR[4,5]). The usage should follow TCG Platform Firmware Profile (PFP) specification.</li> <li>RTMR[2] is for the OS component, such as OS kernel, initrd, and application (match PCR[8~15]). The usage is OS dependent.</li> <li>RTMR[3] is reserved for special usage only.</li> </ul> <h2 id="measured-boot-flow">Measured Boot Flow</h2> <p>In general, the transitions (dotted line in Booting Sequence figure) where events are measured. Hence a trusted chain, i.e., virtual firmware -&gt; bootloaders -&gt; OS -&gt; applications will be built.</p> <p><strong>Measure TdHob and Configuration FV (Cfv)</strong></p> <p><a href="https://cdrdv2.intel.com/v1/dl/getContent/733585" rel="external nofollow noopener" target="_blank">4.2 TD Hand-Off Block (HOB)</a> and <a href="https://cdrdv2.intel.com/v1/dl/getContent/733585" rel="external nofollow noopener" target="_blank">3.2 Configuration Firmware Volume (CFV)</a> are external data provided by Host VMM. These are not trusted in TD guest. So they should be validated, measured and extended to TD RTMR registers. In the meantime 2 <code class="language-plaintext highlighter-rouge">EFI_CC_EVENT_HOB</code> are created. These 2 GUIDed HOBs carry the hash value of TdHobList and Configuration FV. In DXE phase <code class="language-plaintext highlighter-rouge">EFI_CC_EVENT</code> can be created based on these 2 GUIDed HOBs.</p> <p>Configuration Firmware Volume includes all the provisioned data. This region is read only. One possible usage is to provide UEFI Secure Boot Variable content in this region, such as PK, KEK, db, dbx.</p> <p>The TD HOB list is used to pass the information from VMM to TDVF. The TD HOB must include PHIT HOB, Resource Descriptor HOB. Other HOBs are optional.</p> <ul> <li>The TD HOB must include PHIT HOB as the first HOB. EfiMemoryTop, EfiMemoryBottom, EfiFreeMemoryTop, and EfiFreeMemoryBottom shall be zero.</li> <li>The TD HOB must include at least one Resource Description HOB to declare the physical memory resource.</li> </ul> <p><strong><em>0.</em></strong> <code class="language-plaintext highlighter-rouge">SecTdxHelperLib</code> is the SEC instance of TdxHelperLib. It implements the following functions for tdx in SEC phase:</p> <ul> <li> <code class="language-plaintext highlighter-rouge">TdxHelperMeasureTdHob</code> measure/extend TdHob and store the measurement value in workarea.</li> <li> <code class="language-plaintext highlighter-rouge">TdxHelperMeasureCfvImage</code> measure/extend the Configuration FV image and store the measurement value in workarea.</li> <li> <code class="language-plaintext highlighter-rouge">TdxHelperBuildGuidHobForTdxMeasurement</code> builds GuidHob for TDX measurement.</li> </ul> <p><strong>Measure Secure Boot Policy to PCR[7]/RTMR[0]</strong></p> <p><em>1.</em> UEFI Debug Mode.</p> <p>If a platform provides a firmware debugger mode, then the platform shall measure “UEFI Debug Mode” string with <code class="language-plaintext highlighter-rouge">EV_EFI_ACTION</code>. This logic is done at TdTcg2Dxe.c <code class="language-plaintext highlighter-rouge">MeasureSecureBootPolicy()</code>, based upon <a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/SecurityPkg.dec" rel="external nofollow noopener" target="_blank"><code class="language-plaintext highlighter-rouge">PcdFirmwareDebuggerInitialized</code></a>.</p> <p><em>2.</em> The contents of the <code class="language-plaintext highlighter-rouge">SecureBoot</code> variable.</p> <p><em>3.</em> The contents of the <code class="language-plaintext highlighter-rouge">PK</code> variable.</p> <p><em>4.</em> The contents of the <code class="language-plaintext highlighter-rouge">KEK</code> variable.</p> <p><em>5.</em> The contents of the <code class="language-plaintext highlighter-rouge">EFI_IMAGE_SECURITY_DATABASE</code> variable (the DB).</p> <p><em>6.</em> The contents of the <code class="language-plaintext highlighter-rouge">EFI_IMAGE_SECURITY_DATABASE1</code> variable (the DBX).</p> <p><em>7.</em> The contents of the <code class="language-plaintext highlighter-rouge">EFI_IMAGE_SECURITY_DATABASE2</code> (the DBT) variable, if present and not empty.</p> <p>The UEFI secure boot related variables – “SecureBoot”, “PK”, “KEK”, “db”, and “dbx” are unconditionally measured by TdTcg2Dxe.c <code class="language-plaintext highlighter-rouge">ReadAndMeasureSecureVariable()</code>. The event type is <a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" rel="external nofollow noopener" target="_blank"><code class="language-plaintext highlighter-rouge">EV_EFI_VARIABLE_DRIVER_CONFIG</code></a>. If they are not present, a zero size UEFI variable entry will be measured. The “dbt” and “dbr” variables are conditionally measured only if they are present by the routine <code class="language-plaintext highlighter-rouge">MeasureAllSecureVariables()</code>.</p> <p><em>8.</em> Separator.</p> <p><a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" rel="external nofollow noopener" target="_blank"><code class="language-plaintext highlighter-rouge">EV_SEPARATOR</code></a> for PCR7 is handled in TdTcg2Dxe.c <code class="language-plaintext highlighter-rouge">MeasureSecureBootPolicy()</code> when the UEFI variable is ready. It is just after <code class="language-plaintext highlighter-rouge">MeasureAllSecureVariables()</code>. It is earlier than the <code class="language-plaintext highlighter-rouge">ReadyToBoot</code> event signal. The reason is that the PCR7 <code class="language-plaintext highlighter-rouge">EV_SEPARATOR</code> must be between SecureBootPolicy (Configure) and and ImageVerification (Authority).</p> <p><strong>Measure Boot Variable to PCR[1]/RTMR[0]</strong></p> <p><em>9.</em> The UEFI BootOrder Variable and the Boot#### variables (just device paths).</p> <p>The UEFI boot related variables, such as “BootOrder.” and “Boot####” are measured by TdTcg2Dxe.c <code class="language-plaintext highlighter-rouge">ReadAndMeasureBootVariable()</code>. The event type is <a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" rel="external nofollow noopener" target="_blank"><code class="language-plaintext highlighter-rouge">EV_EFI_VARIABLE_BOOT</code></a>. These variables are measured if they are present in <code class="language-plaintext highlighter-rouge">MeasureAllBootVariables()</code>.</p> <p><strong>Upon selecting a boot device,</strong></p> <p><em>10.</em> The boot attempt action “Calling EFI Application from Boot Option”, this means Boot Manager attempting to execute code from a Boot Option (<strong>PCR[4]/RTMR[1]</strong>).</p> <p>The boot attempt action is measured by TdTcg2Dxe.c <code class="language-plaintext highlighter-rouge">OnReadyToBoot()</code>. Before invoking a boot option, it measures the action "Calling EFI Application from Boot Option". After the boot option returns, it measures the action "Returning from EFI Application from Boot Option".</p> <p><em>11.</em> Separator, Draw a line between leaving pre-boot env and entering post-boot env (<strong>PCR[0~6]/RTMR[1]</strong>).</p> <p><em>12.</em> <strong>[Optional] If UEFI Secure Boot is enabled,</strong> measure the entry in the <code class="language-plaintext highlighter-rouge">EFI_IMAGE_SECURITY_DATABASE</code> that was used to validate the UEFI image (<strong>PCR[7]/RTMR[0]</strong>).</p> <p>When UEFI secure boot is enabled, the <a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Library/DxeImageVerificationLib" rel="external nofollow noopener" target="_blank"><code class="language-plaintext highlighter-rouge">DxeImageVerificationLib</code></a> verifies the PE image signature based upon the <a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/Guid/ImageAuthentication.h" rel="external nofollow noopener" target="_blank"><code class="language-plaintext highlighter-rouge">EFI_SIGNATURE_DATA</code></a> in the <a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/Guid/ImageAuthentication.h" rel="external nofollow noopener" target="_blank"><code class="language-plaintext highlighter-rouge">EFI_SIGNATURE_LIST</code></a> of an image signature database. If an <code class="language-plaintext highlighter-rouge">EFI_SIGNATURE_DATA</code> is used to verify the image, then this <code class="language-plaintext highlighter-rouge">EFI_SIGNATURE_DATA</code> will be measured with <a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" rel="external nofollow noopener" target="_blank"><code class="language-plaintext highlighter-rouge">EV_EFI_VARIABLE_AUTHORITY</code></a> in <code class="language-plaintext highlighter-rouge">MeasureVariable()</code> of <a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Library/DxeImageVerificationLib/Measurement.c" rel="external nofollow noopener" target="_blank">Measurement.c</a>.</p> <p><em>13.</em> The GUID Partition Table (GPT) disk geometry (<strong>PCR[5]/RTMR[1]</strong>).</p> <p>When a system boots a boot option in a GUID-named partition of the disk, the GUID partition table (GPT) disk geometry needs to be measured. It is done by <a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Library/DxeTpm2MeasureBootLib/DxeTpm2MeasureBootLib.c" rel="external nofollow noopener" target="_blank">DxeTpm2MeasureBootLib.c</a> <code class="language-plaintext highlighter-rouge">Tcg2MeasureGptTable()</code> in <code class="language-plaintext highlighter-rouge">DxeTpm2MeasureBootHandler()</code>.</p> <p><em>14.</em> The selected UEFI application code PE/COFF image, i.e., OS loader (<strong>PCR[4]/RTMR[1]</strong>).</p> <p>A third party UEFI application, such as a UEFI shell utility, a standard OS loader or an OEM boot option, is measured by DxeTpm2MeasureBootLib.c <code class="language-plaintext highlighter-rouge">Tcg2MeasurePeImage()</code> in <code class="language-plaintext highlighter-rouge">DxeTpm2MeasureBootHandler()</code>. The event type is <a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" rel="external nofollow noopener" target="_blank"><code class="language-plaintext highlighter-rouge">EV_EFI_BOOT_SERVICES_APPLICATION</code></a>. If a UEFI application is an FV which is dispatched in the DXE phase, it is also measured to PCR4 irrespective of whether the FV is measured or unmeasured.</p> <p><strong>Then OS loader, i.e., <a href="https://git.savannah.gnu.org/cgit/grub.git/" rel="external nofollow noopener" target="_blank">Grub2</a> extends the trusted boot chain from virtual firmware into the OS.</strong></p> <p><em>NOTE: Here we do not concern <a href="https://github.com/rhboot/shim" rel="external nofollow noopener" target="_blank">Shim</a> component since we only focus on measured boot. Shim is used to extend the UEFI secure boot concept to Linux.</em></p> <p><em>15.</em> Grub2 measures configuration file (e.g., grub.cfg), grub commands, kernel binary, kernel commands and initrd binary (<strong>PCR[8, 9]/RTMR[2]</strong>). PCR[8] is for the command line string and PCR[9] is for a file binary, as shown in the following table.</p> <p>To support measurements on confidential computing platforms, two patches have been upstreamed, including:</p> <ul> <li><a href="https://git.savannah.gnu.org/cgit/grub.git/commit/?id=4c76565b6cb885b7e144dc27f3612066844e2d19" rel="external nofollow noopener" target="_blank">efi/tpm: Add EFI_CC_MEASUREMENT_PROTOCOL support</a></li> <li><a href="https://git.savannah.gnu.org/cgit/grub.git/commit/?id=86df79275d065d87f4de5c97e456973e8b4a649c" rel="external nofollow noopener" target="_blank">commands/efi/tpm: Re-enable measurements on confidential computing platforms</a></li> </ul> <table> <thead> <tr> <th>PCR Index</th> <th>PCR Usage</th> </tr> </thead> <tbody> <tr> <td>8</td> <td>Grub command line: All executed commands (including those from configuration files) will be logged and measured as entered with a prefix of “grub cmd:”</td> </tr> <tr> <td> </td> <td>Kernel command line: Any command line passed to a kernel will be logged and measured as entered with a prefix of “kernel cmdline:”</td> </tr> <tr> <td> </td> <td>Module command line: Any command line passed to a kernel module will be logged and measured as entered with a prefix of “module cmdline:”</td> </tr> <tr> <td>9</td> <td>Files: Any file read by GRUB will be logged and measured with a descriptive text corresponding to the filename.</td> </tr> </tbody> </table> <p><a href="https://github.com/rhboot/grub2/blob/master/grub-core/commands/tpm.c" rel="external nofollow noopener" target="_blank">tpm.c</a> registers <code class="language-plaintext highlighter-rouge">grub_tpm_verify_string()</code> and <code class="language-plaintext highlighter-rouge">grub_tpm_verify_write()</code> to a grub_file_verifier structure. They will be called by <code class="language-plaintext highlighter-rouge">grub_verify_string()</code> and <code class="language-plaintext highlighter-rouge">grub_verifiers_open()</code> in <a href="https://github.com/rhboot/grub2/blob/master/grub-core/commands/verifiers.c" rel="external nofollow noopener" target="_blank">verifiers.c</a>.</p> <p>when grub2 executes a command line such as <code class="language-plaintext highlighter-rouge">GRUB_VERIFY_MODULE_CMDLINE</code>, <code class="language-plaintext highlighter-rouge">GRUB_VERIFY_KERNEL_CMDLINE</code>, <code class="language-plaintext highlighter-rouge">GRUB_VERIFY_COMMAND</code> or <code class="language-plaintext highlighter-rouge">grub_create_loader_cmdline()</code> in <a href="https://github.com/rhboot/grub2/blob/master/grub-core/lib/cmdline.c" rel="external nofollow noopener" target="_blank">cmdline.c</a>, <code class="language-plaintext highlighter-rouge">grub_verify_string()</code> is used. Finally, <code class="language-plaintext highlighter-rouge">grub_tpm_verify_string()</code> calls <code class="language-plaintext highlighter-rouge">grub_tpm_measure</code> and then <code class="language-plaintext highlighter-rouge">grub_cc_log_event</code> to measure the string to <strong>PCR[8]/RTMR[2]</strong>.</p> <p><code class="language-plaintext highlighter-rouge">grub_verifiers_open()</code> is registered as one of grub_file_filters in <a href="https://github.com/rhboot/grub2/blob/master/include/grub/file.h" rel="external nofollow noopener" target="_blank"><code class="language-plaintext highlighter-rouge">file.h</code></a>. Whenever grub uses <a href="https://github.com/rhboot/grub2/blob/master/grub-core/kern/file.c" rel="external nofollow noopener" target="_blank">file.c</a> <code class="language-plaintext highlighter-rouge">grub_file_open()</code> this filter is invoked. Finally, <code class="language-plaintext highlighter-rouge">grub_tpm_verify_write()</code> calls <code class="language-plaintext highlighter-rouge">grub_tpm_measure</code> and then <code class="language-plaintext highlighter-rouge">grub_cc_log_event</code> to measure the file binary to <strong>PCR[9]/RTMR[2]</strong>.</p> <p><em>16.</em> The boot attempt action “Exit Boot Services Invocation”, this means Boot Manager has sent the call to UEFI to end Boot Services (<strong>PCR[5]/RTMR[1]</strong>).</p> <p><em>17.</em> The boot attempt action “Exit Boot Services Returned with Success”, this means UEFI successfully existed Boot Services and pre-OS environment has been terminated (<strong>PCR[5]/RTMR[1]</strong>).</p> <p>The ExitBootServices action is measured by TdTcg2Dxe.c. If ExitBootServices succeeds, then <code class="language-plaintext highlighter-rouge">OnExitBootServices()</code> is invoked. If ExitBootServices fails, then <code class="language-plaintext highlighter-rouge">OnExitBootServicesFailed()</code> is invoked.</p> <p><strong>If Security Boot Policy update after initial measurement and before <code class="language-plaintext highlighter-rouge">ExitBootServices()</code> has completed,</strong></p> <p><em>18.</em> The platform MAY be restarted OR the variables MUST be remeasured into (<strong>PCR[7]/RTMR[0]</strong>). Additionally the normal update process for setting any of the defined Secure Boot variables SHOULD occur before the initial measurement in PCR[7] or after the call to <code class="language-plaintext highlighter-rouge">ExitBootServices()</code> has completed.</p> <p>The UEFI secure boot variable update is measured in Variable <a href="https://github.com/tianocore/edk2/tree/master/MdeModulePkg/Universal/Variable/RuntimeDxe" rel="external nofollow noopener" target="_blank"><code class="language-plaintext highlighter-rouge">RuntimeDxe</code></a>. If any of the above secure boot related variables are updated, then <a href="https://github.com/tianocore/edk2/blob/master/MdeModulePkg/Universal/Variable/RuntimeDxe/Measurement.c" rel="external nofollow noopener" target="_blank">Measurement.c</a> <code class="language-plaintext highlighter-rouge">MeasureVariable()</code> will measure the new data with <code class="language-plaintext highlighter-rouge">EV_EFI_VARIABLE_DRIVER_CONFIG</code>.</p> <h2 id="attestation">Attestation</h2> <p>We will analyse how to verify the TD Quote from the perspective of the verifier, without focusing on the Quote generation or interactions with the attester. At a high level, it can be broken down into Quote Verification, Event Log Replay and Event Parsing.</p> <h3 id="quote-verification">Quote Verification</h3> <p>A measured boot root of trust (RoT) can issue a report of the MRs, often called a quote or attestation report. This quote is typically a digitally-signed digest of MRs.</p> <p>A verifier then checks that the digest of MRs are signed by a trustworthy key, the RoT for Reporting (RTR). This RTR, aka attestation key, is typically a certified key that signs a report of the MRs. This certification is known as an Endorsement in the IETF RATS Architecture. More details about quote verification could be found in <a href="https://github.com/intel/SGXDataCenterAttestationPrimitives" rel="external nofollow noopener" target="_blank">Intel SGX-based Data Center Attestation Primitives (DCAP)</a>.</p> <h3 id="event-log-replay">Event Log Replay</h3> <p>Event log replay involves deserializing a raw event log and using the events to recalculate all of the measurement registers. Each event contains a digest and a measurement register index. The verifier will create simulated measurement registers and, for each event, extend the event digest into its corresponding simulated register. At the end, the verifier compares the simulated register values against the actual quoted measurement register values from the first step.</p> <p>Intel provides a Python library called <a href="https://github.com/canonical/tdx/tree/main/tests/lib/tdx-tools/src/tdxtools" rel="external nofollow noopener" target="_blank">tdx-tools</a> to verify TD measurements. It consists of the following three steps. For the step-by-step flow, please refer to class <code class="language-plaintext highlighter-rouge">VerifyActor</code> defined in tdx-tools.</p> <ul> <li>Get TD event log from CCEL ACPI table.</li> <li>Get TDREPORT via Linux attestation driver.</li> <li>Compare RTMR value from TDREPORT and RTMR value replayed via event log.</li> </ul> <p>The two values are expected to be identical, which means the measured contents are not tampered with.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">VerifyActor</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">
    Actor to verify the RTMR
    </span><span class="sh">"""</span>

    <span class="k">def</span> <span class="nf">_verify_single_rtmr</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">rtmr_index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">rtmr_value_1</span><span class="p">:</span> <span class="n">RTMR</span><span class="p">,</span>
        <span class="n">rtmr_value_2</span><span class="p">:</span> <span class="n">RTMR</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>

        <span class="k">if</span> <span class="n">rtmr_value_1</span> <span class="o">==</span> <span class="n">rtmr_value_2</span><span class="p">:</span>
            <span class="n">LOG</span><span class="p">.</span><span class="nf">info</span><span class="p">(</span><span class="sh">"</span><span class="s">RTMR[%d] passed the verification.</span><span class="sh">"</span><span class="p">,</span> <span class="n">rtmr_index</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">LOG</span><span class="p">.</span><span class="nf">error</span><span class="p">(</span><span class="sh">"</span><span class="s">RTMR[%d] did not pass the verification</span><span class="sh">"</span><span class="p">,</span> <span class="n">rtmr_index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">verify_rtmr</span><span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="sh">"""</span><span class="s">
        Get TD report and RTMR replayed by event log to do verification.
        </span><span class="sh">"""</span>
        <span class="c1"># 1. Read CCEL from ACPI table at /sys/firmware/acpi/tables/CCEL
</span>        <span class="n">ccelobj</span> <span class="o">=</span> <span class="n">CCEL</span><span class="p">.</span><span class="nf">create_from_acpi_file</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">ccelobj</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c1"># 2. Get the start address and length for event log area
</span>        <span class="n">td_event_log_actor</span> <span class="o">=</span> <span class="nc">TDEventLogActor</span><span class="p">(</span>
            <span class="n">ccelobj</span><span class="p">.</span><span class="n">log_area_start_address</span><span class="p">,</span>
            <span class="n">ccelobj</span><span class="p">.</span><span class="n">log_area_minimum_length</span><span class="p">)</span>

        <span class="c1"># 3. Collect event log and replay the RTMR value according to event log
</span>        <span class="n">td_event_log_actor</span><span class="p">.</span><span class="nf">replay</span><span class="p">()</span>

        <span class="c1"># 4. Read TD REPORT via TDCALL.GET_TDREPORT
</span>        <span class="n">td_report</span> <span class="o">=</span> <span class="n">TdReport</span><span class="p">.</span><span class="nf">get_td_report</span><span class="p">()</span>

        <span class="c1"># 5. Verify individual RTMR value from TDREPORT and recalculated from
</span>        <span class="c1">#    event log
</span>        <span class="n">self</span><span class="p">.</span><span class="nf">_verify_single_rtmr</span><span class="p">(</span>
            <span class="mi">0</span><span class="p">,</span>
            <span class="n">td_event_log_actor</span><span class="p">.</span><span class="nf">get_rtmr_by_index</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
            <span class="nc">RTMR</span><span class="p">(</span><span class="nf">bytearray</span><span class="p">(</span><span class="n">td_report</span><span class="p">.</span><span class="n">td_info</span><span class="p">.</span><span class="n">rtmr_0</span><span class="p">)))</span>

        <span class="n">self</span><span class="p">.</span><span class="nf">_verify_single_rtmr</span><span class="p">(</span>
            <span class="mi">1</span><span class="p">,</span>
            <span class="n">td_event_log_actor</span><span class="p">.</span><span class="nf">get_rtmr_by_index</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
            <span class="nc">RTMR</span><span class="p">(</span><span class="nf">bytearray</span><span class="p">(</span><span class="n">td_report</span><span class="p">.</span><span class="n">td_info</span><span class="p">.</span><span class="n">rtmr_1</span><span class="p">)))</span>

        <span class="n">self</span><span class="p">.</span><span class="nf">_verify_single_rtmr</span><span class="p">(</span>
            <span class="mi">2</span><span class="p">,</span>
            <span class="n">td_event_log_actor</span><span class="p">.</span><span class="nf">get_rtmr_by_index</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span>
            <span class="nc">RTMR</span><span class="p">(</span><span class="nf">bytearray</span><span class="p">(</span><span class="n">td_report</span><span class="p">.</span><span class="n">td_info</span><span class="p">.</span><span class="n">rtmr_2</span><span class="p">)))</span>

        <span class="n">self</span><span class="p">.</span><span class="nf">_verify_single_rtmr</span><span class="p">(</span>
            <span class="mi">3</span><span class="p">,</span>
            <span class="n">td_event_log_actor</span><span class="p">.</span><span class="nf">get_rtmr_by_index</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span>
            <span class="nc">RTMR</span><span class="p">(</span><span class="nf">bytearray</span><span class="p">(</span><span class="n">td_report</span><span class="p">.</span><span class="n">td_info</span><span class="p">.</span><span class="n">rtmr_3</span><span class="p">)))</span>
</code></pre></div></div> <h3 id="event-parsing">Event Parsing</h3> <p>Event parsing is the process of pulling information from the events. The verifier uses the output to make verification decisions against the appraisal policy, endorsements, and reference values.</p> <p>In <a href="https://github.com/google/go-eventlog" rel="external nofollow noopener" target="_blank">go-eventlog</a>, <code class="language-plaintext highlighter-rouge">ReplayAndExtract</code> parses a CC event log and replays the parsed event log against the RTMR bank specified by hash (the second step). It then extracts event info from the verified log into a FirmwareLogState. In this FirmwareLogState, includes details about the firmware, secure boot configuration, bootloaders (such as grub) and kernel (also includes command line and initramfs).</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// FirmwareLogState extracts event info from a verified TCG PC Client event</span>
<span class="c">// log into a FirmwareLogState.</span>
<span class="c">//</span>
<span class="c">// It is the caller's responsibility to ensure that the passed events have</span>
<span class="c">// been replayed (e.g., using `tcg.ParseAndReplay`) against a verified measurement</span>
<span class="c">// register bank.</span>
<span class="k">func</span> <span class="n">FirmwareLogState</span><span class="p">(</span><span class="n">events</span> <span class="p">[]</span><span class="n">tcg</span><span class="o">.</span><span class="n">Event</span><span class="p">,</span> <span class="n">hash</span> <span class="n">crypto</span><span class="o">.</span><span class="n">Hash</span><span class="p">,</span> <span class="n">registerCfg</span> <span class="n">registerConfig</span><span class="p">,</span> <span class="n">opts</span> <span class="n">Opts</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="n">pb</span><span class="o">.</span><span class="n">FirmwareLogState</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">var</span> <span class="n">joined</span> <span class="kt">error</span>
	<span class="n">tcgHash</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">tpm2</span><span class="o">.</span><span class="n">HashToAlgorithm</span><span class="p">(</span><span class="n">hash</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="no">nil</span><span class="p">,</span> <span class="n">err</span>
	<span class="p">}</span>

	<span class="n">platform</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">registerCfg</span><span class="o">.</span><span class="n">PlatformExtracter</span><span class="p">(</span><span class="n">hash</span><span class="p">,</span> <span class="n">events</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
		<span class="n">joined</span> <span class="o">=</span> <span class="n">errors</span><span class="o">.</span><span class="n">Join</span><span class="p">(</span><span class="n">joined</span><span class="p">,</span> <span class="n">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="n">sbState</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">SecureBootState</span><span class="p">(</span><span class="n">events</span><span class="p">,</span> <span class="n">registerCfg</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
		<span class="n">joined</span> <span class="o">=</span> <span class="n">errors</span><span class="o">.</span><span class="n">Join</span><span class="p">(</span><span class="n">joined</span><span class="p">,</span> <span class="n">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="n">efiState</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">EfiState</span><span class="p">(</span><span class="n">hash</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">registerCfg</span><span class="p">)</span>

	<span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
		<span class="n">joined</span> <span class="o">=</span> <span class="n">errors</span><span class="o">.</span><span class="n">Join</span><span class="p">(</span><span class="n">joined</span><span class="p">,</span> <span class="n">err</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">var</span> <span class="n">grub</span> <span class="o">*</span><span class="n">pb</span><span class="o">.</span><span class="n">GrubState</span>
	<span class="k">var</span> <span class="n">kernel</span> <span class="o">*</span><span class="n">pb</span><span class="o">.</span><span class="n">LinuxKernelState</span>
	<span class="k">if</span> <span class="n">opts</span><span class="o">.</span><span class="n">Loader</span> <span class="o">==</span> <span class="n">GRUB</span> <span class="p">{</span>
		<span class="n">grub</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="n">registerCfg</span><span class="o">.</span><span class="n">GRUBExtracter</span><span class="p">(</span><span class="n">hash</span><span class="p">,</span> <span class="n">events</span><span class="p">)</span>

		<span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
			<span class="n">joined</span> <span class="o">=</span> <span class="n">errors</span><span class="o">.</span><span class="n">Join</span><span class="p">(</span><span class="n">joined</span><span class="p">,</span> <span class="n">err</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="n">kernel</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="n">LinuxKernelStateFromGRUB</span><span class="p">(</span><span class="n">grub</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
			<span class="n">joined</span> <span class="o">=</span> <span class="n">errors</span><span class="o">.</span><span class="n">Join</span><span class="p">(</span><span class="n">joined</span><span class="p">,</span> <span class="n">err</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">pb</span><span class="o">.</span><span class="n">FirmwareLogState</span><span class="p">{</span>
		<span class="n">Platform</span><span class="o">:</span>    <span class="n">platform</span><span class="p">,</span>
		<span class="n">SecureBoot</span><span class="o">:</span>  <span class="n">sbState</span><span class="p">,</span>
		<span class="n">Efi</span><span class="o">:</span>         <span class="n">efiState</span><span class="p">,</span>
		<span class="n">RawEvents</span><span class="o">:</span>   <span class="n">tcg</span><span class="o">.</span><span class="n">ConvertToPbEvents</span><span class="p">(</span><span class="n">hash</span><span class="p">,</span> <span class="n">events</span><span class="p">),</span>
		<span class="n">Hash</span><span class="o">:</span>        <span class="n">pb</span><span class="o">.</span><span class="n">HashAlgo</span><span class="p">(</span><span class="n">tcgHash</span><span class="p">),</span>
		<span class="n">Grub</span><span class="o">:</span>        <span class="n">grub</span><span class="p">,</span>
		<span class="n">LinuxKernel</span><span class="o">:</span> <span class="n">kernel</span><span class="p">,</span>
	<span class="p">},</span> <span class="n">joined</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="reference-measurements">Reference Measurements</h3> <p>The remaining topic is a quite complex challenge: how to generate reference measurements for FirmwareLogState. Now it is still a open issue <a href="https://github.com/canonical/tdx/issues/263" rel="external nofollow noopener" target="_blank">Calculate measurements outside of TDX #263</a> in the tdx repo. Inspired by a tool called <a href="https://github.com/cc-api/cvm-image-rewriter" rel="external nofollow noopener" target="_blank">cvm-image-rewriter</a> in cc-api repo, we may design a plugin to calculate reference measurements of the VM image.</p> <p>The cvm-image-rewriter tool is plugin-based and used to customize the confidential VM guest including guest image, config, OVMF firmware etc. The following table shows some existing plugins.</p> <table> <thead> <tr> <th>Name</th> <th>Descriptions</th> </tr> </thead> <tbody> <tr> <td>01-resize-image</td> <td>Resize the input qcow2 image</td> </tr> <tr> <td>02-motd-welcome</td> <td>Customize the login welcome message</td> </tr> <tr> <td>03-netplan</td> <td>Customize the netplan.yaml</td> </tr> <tr> <td>04-user-authkey</td> <td>Add auth key for user login instead of password</td> </tr> <tr> <td>05-readonly-data</td> <td>Fix some file permission to ready-only</td> </tr> <tr> <td>06-install-tdx-guest-kernel</td> <td>Install MVP TDX guest kernel</td> </tr> <tr> <td>07-device-permission</td> <td>Fix the permission for device node</td> </tr> <tr> <td>08-ccnp-uds-directory-permission</td> <td>Fix the permission for CCNP UDS directory</td> </tr> <tr> <td>60-initrd-update</td> <td>Update the initrd image</td> </tr> <tr> <td>97-sample</td> <td>plugin customization example</td> </tr> <tr> <td>98-ima-enable-simple</td> <td>Enable IMA (Integrity Measurement Architecture) feature</td> </tr> </tbody> </table> <p>After customising the VM image, a plugin (possibly named reference-measurement-calculator) can read the grub and kernel, then compute the digest of the images and configurations. Therefore reference measurements of VM image is obtained for final verification.</p> <p>Next question is how to get reference measurements about the firmware. According to TDVF Binary Layout, we can parse the virtual firmware, locate the BFV and CFV, and then compute their reference measurements. Here, we recommend referring to this tool named <a href="https://github.com/edgelesssys/contrast/blob/main/tools/tdx-measure/tdvf/tdvf.go" rel="external nofollow noopener" target="_blank">tdx-measure</a> in contrast repo.</p> <p>The tool also attempts another attestation approach. It does RTMR precalulation for given firmware and kernel file (see <code class="language-plaintext highlighter-rouge">newRtMrCmd()</code> function), and compare RTMR value from TDREPORT and pre-computed RTMR value. This improves verification efficiency by eliminating the need for the event log. It is important to note that this method is suitable for relatively fixed scenarios. The event logs are still necessary in most scenarios, because firmware, bootloaders, OS and applications are free to append measurements for any event, in any order.</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">newRtMrCmd</span><span class="p">()</span> <span class="o">*</span><span class="n">cobra</span><span class="o">.</span><span class="n">Command</span> <span class="p">{</span>
	<span class="n">cmd</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="n">cobra</span><span class="o">.</span><span class="n">Command</span><span class="p">{</span>
		<span class="n">Use</span><span class="o">:</span>   <span class="s">"rtmr -f OVMF.fd -k bzImage [0|1|2|3]"</span><span class="p">,</span>
		<span class="n">Short</span><span class="o">:</span> <span class="s">"calculate the RTMR for a firmware and kernel file"</span><span class="p">,</span>
		<span class="n">Long</span><span class="o">:</span> <span class="s">`Calculate the RTMR for a firmware and kernel file.

		This will parse the firmware according to the TDX Virtual Firmware Design Guide
		and/or hash the kernel and pre-calculate a given RTMR.`</span><span class="p">,</span>
		<span class="n">Args</span><span class="o">:</span>      <span class="n">cobra</span><span class="o">.</span><span class="n">MatchAll</span><span class="p">(</span><span class="n">cobra</span><span class="o">.</span><span class="n">ExactArgs</span><span class="p">(</span><span class="m">1</span><span class="p">),</span> <span class="n">cobra</span><span class="o">.</span><span class="n">OnlyValidArgs</span><span class="p">),</span>
		<span class="n">ValidArgs</span><span class="o">:</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">"0"</span><span class="p">,</span> <span class="s">"1"</span><span class="p">,</span> <span class="s">"2"</span><span class="p">,</span> <span class="s">"3"</span><span class="p">},</span>
		<span class="n">RunE</span><span class="o">:</span>      <span class="n">runRtMr</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="n">cmd</span><span class="o">.</span><span class="n">Flags</span><span class="p">()</span><span class="o">.</span><span class="n">StringP</span><span class="p">(</span><span class="s">"firmware"</span><span class="p">,</span> <span class="s">"f"</span><span class="p">,</span> <span class="s">"OVMF.fd"</span><span class="p">,</span> <span class="s">"path to firmware file"</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">cmd</span><span class="o">.</span><span class="n">MarkFlagFilename</span><span class="p">(</span><span class="s">"firmware"</span><span class="p">,</span> <span class="s">"fd"</span><span class="p">);</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="n">cmd</span><span class="o">.</span><span class="n">Flags</span><span class="p">()</span><span class="o">.</span><span class="n">StringP</span><span class="p">(</span><span class="s">"kernel"</span><span class="p">,</span> <span class="s">"k"</span><span class="p">,</span> <span class="s">"bzImage"</span><span class="p">,</span> <span class="s">"path to kernel file"</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">cmd</span><span class="o">.</span><span class="n">MarkFlagFilename</span><span class="p">(</span><span class="s">"kernel"</span><span class="p">);</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="n">cmd</span><span class="o">.</span><span class="n">Flags</span><span class="p">()</span><span class="o">.</span><span class="n">StringP</span><span class="p">(</span><span class="s">"initrd"</span><span class="p">,</span> <span class="s">"i"</span><span class="p">,</span> <span class="s">"initrd.zst"</span><span class="p">,</span> <span class="s">"path to initrd file"</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">cmd</span><span class="o">.</span><span class="n">MarkFlagFilename</span><span class="p">(</span><span class="s">"initrd"</span><span class="p">);</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="n">cmd</span><span class="o">.</span><span class="n">Flags</span><span class="p">()</span><span class="o">.</span><span class="n">StringP</span><span class="p">(</span><span class="s">"cmdline"</span><span class="p">,</span> <span class="s">"c"</span><span class="p">,</span> <span class="s">""</span><span class="p">,</span> <span class="s">"kernel command line"</span><span class="p">)</span>
	<span class="k">return</span> <span class="n">cmd</span>
<span class="p">}</span>
</code></pre></div></div> <h2 id="appendix">Appendix</h2> <p><span id="jumpA"></span></p> <h3 id="tdvf-configurations">TDVF Configurations</h3> <p><strong>Config-A</strong>:</p> <ul> <li>Merge the <em>basic</em> TDVF feature to existing <code class="language-plaintext highlighter-rouge">OvmfX64Pkg.dsc</code>. (Align with existing SEV)</li> <li>Threat model: VMM is NOT out of TCB. (We don’t make things worse)</li> <li>The <code class="language-plaintext highlighter-rouge">OvmfX64Pkg.dsc</code> includes SEV/TDX/normal OVMF basic boot capability. The final binary can run on SEV/TDX/normal OVMF.</li> <li>No changes to existing OvmfPkgX64 image layout.</li> <li>No need to remove features if they exist today.</li> <li>PEI phase is NOT skipped in either TD or Non-TD.</li> <li>RTMR based measurement is supported.</li> <li>External inputs from Host VMM are measured, such as TdHob, CFV.</li> <li>Other external inputs are measured, such as FW_CFG data, os loader, initrd, etc.</li> </ul> <p><strong>Build the TDVF (Config-A) target:</strong></p> <p><a href="https://git.codelinaro.org/linaro/dcap/edk2/-/commit/4d37059d8e1eeda124270a158416795605327cbd" rel="external nofollow noopener" target="_blank">OvmfPkg: Support Tdx measurement in OvmfPkgX64</a></p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd</span> /path/to/edk2
<span class="nb">source </span>edksetup.sh
build.sh <span class="nt">-p</span> OvmfPkg/OvmfPkgX64.dsc <span class="nt">-a</span> X64 <span class="nt">-t</span> GCC5
</code></pre></div></div> <p><strong>Config-B</strong>:</p> <ul> <li>Add a standalone <code class="language-plaintext highlighter-rouge">IntelTdx.dsc</code> to a TDX specific directory for a <em>full</em>  feature TDVF.(Align with existing SEV)</li> <li>Threat model: VMM is out of TCB. (We need necessary change to prevent attack from VMM)</li> <li> <code class="language-plaintext highlighter-rouge">IntelTdx.dsc</code> includes TDX/normal OVMF basic boot capability. The final binary can run on TDX/normal OVMF.</li> <li>It might eventually merge with AmdSev.dsc, but NOT at this point of time. And we don’t know when it will happen. We need sync with AMD in the community after both of us think the solutions are mature to merge.</li> <li>Need to add necessary security feature as mandatory requirement, such as RTMR based Trusted Boot support.</li> <li>Need to measure the external input from Host VMM, such as TdHob, CFV.</li> <li>Need to measure other external input, such as FW_CFG data, os loader, initrd, etc.</li> <li>Need to remove unnecessary attack surfaces, such as network stack.</li> </ul> <p><strong>Build the TDVF (Config-B) target:</strong></p> <p><a href="https://git.codelinaro.org/linaro/dcap/edk2/-/commit/44a53a3bdd9c76e37f1750b5aa6a745de5d77391" rel="external nofollow noopener" target="_blank">OvmfPkg: Introduce IntelTdxX64 for TDVF Config-B</a></p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd</span> /path/to/edk2
<span class="nb">set </span><span class="nv">PACKAGES_PATH</span><span class="o">=</span>/path/to/edk2/OvmfPkg
<span class="nb">source </span>edksetup.sh
build.sh <span class="nt">-p</span> OvmfPkg/IntelTdx/IntelTdxX64.dsc <span class="nt">-a</span> X64 <span class="nt">-t</span> GCC5
</code></pre></div></div> <p><span id="jumpB"></span></p> <h3 id="uefi-boot-phase">UEFI Boot Phase</h3> <p>UEFI has six main boot phases, which are all critical in the initialization process of the platform. The combined phases are referred to as the Platform Initialization or PI.</p> <p><em>1.</em> Security (SEC)</p> <p>This phase is the primary stage of the UEFI boot process, and will generally be used to: initialize a temporary memory store, act as the root of trust in the system and provide information to the Pre-EFI core phase. This root of trust is a mechanism that ensures any code that is executed in the PI is cryptographically validated (digitally signed), creating a “secure boot” environment.</p> <p><em>2.</em> Pre-EFI Initialization (PEI)</p> <p>This is the second stage of the boot process and involves using only the CPU’s current resources to dispatch Pre-EFI Initialization Modules (PEIMs). These are used to perform initialization of specific boot-critical operations such as memory initialization, whilst also allowing control to pass to the Driver Execution Environment (DXE).</p> <p><em>3.</em> Driver Execution Environment (DXE)</p> <p>The DXE phase is where the majority of the system initialization occurs. In the PEI stage, the memory required for the DXE to operate is allocated and initialized, and upon control being passed to the DXE, the DXE Dispatcher is then invoked. The dispatcher will perform the loading and execution of hardware drivers, runtime services, and any boot services required for the operating system to start.</p> <p><em>4.</em> Boot Device Selection (BDS)</p> <p>Upon completion of the DXE Dispatcher executing all DXE drivers, control is passed to the BDS. This stage is responsible for initializing console devices and any remaining devices that are required. The selected boot entry (OS loader) is then loaded and executed in preparation for the Transient System Load (TSL).</p> <p><em>5.</em> Transient System Load (TSL)</p> <p>In this phase, the PI process is now directly between the boot selection and the expected hand-off to the main operating system phase. Here, an application such as the UEFI shell may be invoked, or (more commonly) a boot loader will run in order to prepare the final OS environment. The boot loader is usually responsible for terminating the UEFI Boot Services via the ExitBootServices() call. However, it is also possible for the OS itself to do this, such as the Linux kernel with CONFIG_EFI_STUB.</p> <p><em>6.</em> Runtime (RT)</p> <p>The final phase is the runtime one. Here is where the final handoff to the OS occurs. The UEFI compatible OS now takes over the system. The UEFI runtime services remain available for the OS to use, such as for querying and writing variables from NVRAM.</p> </div> </article> </div> </div> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2025 Haocheng Ma. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script defer src="/assets/js/bootstrap-toc.min.js?c82ff4de8b0955d6ff14f5b05eed7eb6"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>addBackToTop();</script> <script type="module" src="/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script>let searchTheme=determineComputedTheme();const ninjaKeys=document.querySelector("ninja-keys");"dark"===searchTheme?ninjaKeys.classList.add("dark"):ninjaKeys.classList.remove("dark");const openSearchModal=()=>{const e=$("#navbarNav");e.hasClass("show")&&e.collapse("hide"),ninjaKeys.open()};</script> <script>const ninja=document.querySelector("ninja-keys");ninja.data=[{id:"nav-about",title:"about",section:"Navigation",handler:()=>{window.location.href="/"}},{id:"nav-blog",title:"blog",description:"",section:"Navigation",handler:()=>{window.location.href="/blog/"}},{id:"nav-publications",title:"publications",description:"publications by categories in reversed chronological order.",section:"Navigation",handler:()=>{window.location.href="/publications/"}},{id:"post-measured-boot-in-intel-tdx-39-s-grub-boot",title:"Measured boot in Intel TDX&#39;s grub boot",description:"How to build a trusted chain when launch TD guest using grub boot.",section:"Posts",handler:()=>{window.location.href="/blog/2025/tdx-measure-boot/"}},{id:"socials-email",title:"Send email",section:"Socials",handler:()=>{window.open("mailto:%61%6E%64%72%65%77%6D%61%68%63@%67%6D%61%69%6C.%63%6F%6D","_blank")}},{id:"socials-orcid",title:"ORCID",section:"Socials",handler:()=>{window.open("https://orcid.org/0000-0002-7118-9379","_blank")}},{id:"socials-google-scholar",title:"Google Scholar",section:"Socials",handler:()=>{window.open("https://scholar.google.com/citations?user=cdWqgwUAAAAJ","_blank")}},{id:"socials-github",title:"GitHub",section:"Socials",handler:()=>{window.open("https://github.com/haocheng-ma","_blank")}},{id:"light-theme",title:"Change theme to light",description:"Change the theme of the site to Light",section:"Theme",handler:()=>{setThemeSetting("light")}},{id:"dark-theme",title:"Change theme to dark",description:"Change the theme of the site to Dark",section:"Theme",handler:()=>{setThemeSetting("dark")}},{id:"system-theme",title:"Use system default theme",description:"Change the theme of the site to System Default",section:"Theme",handler:()=>{setThemeSetting("system")}}];</script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>