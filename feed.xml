<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="haocheng-ma.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="haocheng-ma.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-01-13T14:45:11+00:00</updated><id>haocheng-ma.github.io/feed.xml</id><title type="html">blank</title><subtitle>Haocheng&apos;s academic webpage. </subtitle><entry><title type="html">Measured boot in Intel TDX’s grub boot</title><link href="haocheng-ma.github.io/blog/2025/tdx-measure-boot/" rel="alternate" type="text/html" title="Measured boot in Intel TDX’s grub boot"/><published>2025-01-12T00:00:00+00:00</published><updated>2025-01-12T00:00:00+00:00</updated><id>haocheng-ma.github.io/blog/2025/tdx-measure-boot</id><content type="html" xml:base="haocheng-ma.github.io/blog/2025/tdx-measure-boot/"><![CDATA[<p>Intel Trust Domain Extension (TDX) is Intel Architecture extension to provide trusted, isolated VM execution by removing CSP software (hypervisor etc) from the TCB. <strong>TDX Virtual Firmware (TDVF)</strong> is an EDK II based project to enable UEFI support for TDX based Virtual Machines. It provides the capability to launch a TD. TDVF allows two configurations with different features, please see Annex B from <a href="https://github.com/tianocore/edk2/blob/master/OvmfPkg/IntelTdx/README.md">Configurations and Features</a>.</p> <p><strong>In the upcoming series of articles, we focus on different types of TD boot.</strong></p> <h2 id="td-boot-types">TD Boot Types</h2> <p>The following diagram illustrates the TD boot type and boot process.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2025-01-12-tdx-measure-boot/td_guest_boot_process.png" sizes="95vw"/> <img src="/assets/img/2025-01-12-tdx-measure-boot/td_guest_boot_process.png" class="img-fluid rounded z-depth-0 mx-auto d-block" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <div class="caption">     Figure 1. TD Guest Boot Process </div> <p><strong>Direct boot</strong> is a boot process where the system boots directly into the OS without an intermediate boot loader. It can also be referred to as direct kernel boot with firmware, in which firmware loads kernel and initrd through the FwCfg device provided by Qemu.</p> <p><strong>Grub boot</strong> involves using the Grub bootloader, which provides advanced boot menu options, allowing you to select different operating systems and customize boot configurations. It can also be referred to as firmware-only boot, in which firmware launches a bootloader from a disk image.</p> <p>The detailed boot flow for different TD boot methods can be found in Figure 2.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2025-01-12-tdx-measure-boot/detailed_flow_for_different_td_boot.png" sizes="95vw"/> <img src="/assets/img/2025-01-12-tdx-measure-boot/detailed_flow_for_different_td_boot.png" class="img-fluid rounded z-depth-0 mx-auto d-block" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <div class="caption">     Figure 2. Detailed Flow for Different TD Boot </div> <p><strong>Today we will be diving into Measured Boot in Grub Boot.</strong></p> <p>In the virtual firmware, i.e., OVMF, the image handler <code class="language-plaintext highlighter-rouge">DxeTpmMeasureBootHandler</code> will be triggered when loading EFI image via <code class="language-plaintext highlighter-rouge">CoreLoadImageCommon()</code>. The <code class="language-plaintext highlighter-rouge">DxeTpmMeasureBootHandler</code> measures the objects like FV, QEMU CFG, VMM Hob, Variable into TCG PCR Register. In TD, if vTPM doesn’t exist, the measurement will be extended to RTMR. Then in boot loader ShimX64.efi, <code class="language-plaintext highlighter-rouge">TpmMeasureVariable()</code> measures the secure boot’s certificates into TCG PCR or TDX RTMR register. Finally, boot loader GrubX64.efi measures kernel binary and cmdline, initrd binary, and grub’s module into TCG PCR or TDX RTMR register. The mapping between TCG PCR register and RTMR is as below.</p> <ul> <li>PCR[1, 7] &lt;–&gt; RTMR[0]</li> <li>PCR[2-6] &lt;–&gt; RTMR[1]</li> <li>PCR[8-15] &lt;–&gt; RTMR[2]</li> </ul> <h2 id="uefi-boot-sequence">UEFI Boot Sequence</h2> <p>UEFI allows the extension of platform firmware by loading UEFI driver and UEFI application images. When UEFI drivers and UEFI applications are loaded they have access to all UEFI-defined runtime and boot services. See the Booting Sequence Figure 3 below.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2025-01-12-tdx-measure-boot/uefi_booting_sequence.png" sizes="95vw"/> <img src="/assets/img/2025-01-12-tdx-measure-boot/uefi_booting_sequence.png" class="img-fluid rounded z-depth-0 mx-auto d-block" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <div class="caption">     Figure 3. UEFI Booting Sequence </div> <p>UEFI allows the consolidation of boot menus from the OS loader and platform firmware into a single platform firmware menu. These platform firmware menus will allow the selection of any UEFI OS loader from any partition on any boot medium that is supported by UEFI boot services.</p> <p>The OS loader operates as a UEFI application, utilizing UEFI services via Boot Services (BS) and Runtime Services (RT). It then invokes <code class="language-plaintext highlighter-rouge">ExitBootServices()</code> to terminate BS and release its resources, with only RT remaining available to the OS.</p> <p>A detailed introduction to UEFI boot phases refers to Annex B from <a href="https://secret.club/2020/05/26/introduction-to-uefi-part-1.html#uefi-boot-phases">UEFI boot phases</a>.</p> <h2 id="measured-boot-component">Measured Boot Component</h2> <p>See Figure 4, the pre-boot environment before the kernel includes the TDVF/OVMF phase and the bootloader phase (shim and grub). The whole boot chain will be measured into RTMR via <code class="language-plaintext highlighter-rouge">EFI_CC_MEASUREMENT_PROTOCOL</code>.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2025-01-12-tdx-measure-boot/td_measurement_process.png" sizes="95vw"/> <img src="/assets/img/2025-01-12-tdx-measure-boot/td_measurement_process.png" class="img-fluid rounded z-depth-0 mx-auto d-block" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <div class="caption">     Figure 4. TD Measurement Process </div> <p>Similar to the TCG event log, <code class="language-plaintext highlighter-rouge">EFI_CC_MEASUREMENT_PROTOCOL</code> logs the events into ACPI table CCEL and the measurement hash is extended to the corresponding RTMR register. The event logs in CCEL table can be replayed within a TD guest to verify the RTMR value.</p> <p>The Measured Boot Component in EDK2 is as follows.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2025-01-12-tdx-measure-boot/measured_boot_component_in_edk2.png" sizes="95vw"/> <img src="/assets/img/2025-01-12-tdx-measure-boot/measured_boot_component_in_edk2.png" class="img-fluid rounded z-depth-0 mx-auto d-block" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <div class="caption">     Figure 5. Measured Boot Component in EDK2 </div> <p>The <a href="https://github.com/tianocore/edk2/tree/master/OvmfPkg/IntelTdx/TdxHelperLib"><code class="language-plaintext highlighter-rouge">SecTdxHelperLib</code></a> library provides measurement functions in SEC phase. The <a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/Protocol/CcMeasurement.h"><code class="language-plaintext highlighter-rouge">EFI_CC_MEASUREMENT_PROTOCOL</code></a> protocol abstracts the confidential computing (CC) measurement operation in UEFI guest environment. The <a href="https://github.com/tianocore/edk2/blob/master/OvmfPkg/Tcg/TdTcg2Dxe/TdTcg2Dxe.c">TdTcg2Dxe.c</a> DXE driver handles the DXE phase measurement. The <a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Library/DxeTpm2MeasureBootLib"><code class="language-plaintext highlighter-rouge">DxeTpm2MeasureBootLib</code></a> library handles the PE image measurements and GPT measurement. All event type definition can be found at <a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h"><code class="language-plaintext highlighter-rouge">UefiTcgPlatform.h</code></a>.</p> <p>Here we give a description of <strong><code class="language-plaintext highlighter-rouge">EFI_CC_MEASUREMENT_PROTOCOL</code></strong> from <a href="https://uefi.org/specs/UEFI/2.10/38_Confidential_Computing.html#">Confidential Computing in UEFI Specification</a>.</p> <p>If a virtual firmware with CC capability supports measurement, the virtual firmware should produce <a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/Protocol/CcMeasurement.h"><code class="language-plaintext highlighter-rouge">EFI_CC_MEASUREMENT_PROTOCOL</code></a> with new GUID <code class="language-plaintext highlighter-rouge">EFI_CC_MEASUREMENT_PROTOCOL_GUID</code> to report event log and provide hash capability. In summary, this protocol abstracts the CC measurement operation in UEFI guest environment.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define EFI_CC_MEASUREMENT_PROTOCOL_GUID \
{0x96751a3d, 0x72f4, 0x41a6, {0xa7, 0x94, 0xed, 0x5d, 0xe, 0x67, 0xae, 0x6b }}
# Protocol Interface Structure
</span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_EFI_CC_MEASUREMENT_PROTOCOL</span> <span class="p">{</span>
  <span class="n">EFI_CC_GET_CAPABILITY</span>          <span class="n">GetCapability</span><span class="p">;</span>
  <span class="n">EFI_CC_GET_EVENT_LOG</span>           <span class="n">GetEventLog</span><span class="p">;</span>
  <span class="n">EFI_CC_HASH_LOG_EXTEND_EVENT</span>   <span class="n">HashLogExtendEvent</span><span class="p">;</span>
  <span class="n">EFI_CC_MAP_PCR_TO_MR_INDEX</span>     <span class="n">MapPcrToMrIndex</span><span class="p">;</span>
<span class="p">}</span> <span class="n">EFI_CC_MEASUREMENT_PROTOCOL</span><span class="p">;</span>
</code></pre></div></div> <p>This protocol defines four parameters in the above interface structure, including:</p> <ol> <li> <p>GetCapability</p> <p>Provide protocol capability information and state information.</p> </li> <li> <p>GetEventLog</p> <p>Allow a caller to retrieve the address of a given event log and its last entry.</p> </li> <li> <p>HashLogExtendEvent</p> <p>Provide callers with an opportunity to extend and optionally log events without requiring knowledge of actual CC command.</p> </li> <li> <p>MapPcrToMrIndex</p> <p>Provide callers information on TPM PCR to CC measurement register (MR) mapping.</p> </li> </ol> <p><strong>Mapping for Intel TDX</strong></p> <p>The following table shows the TPM PCR index mapping and CC event log measurement register index interpretation for Intel TDX, where MRTD means Trust Domain Measurement Register and RTMR means Runtime Measurement Register. There certainly are fewer TD measurement registers than TPM Platform Configuration Registers (PCRs). They are typically mapped as below:</p> <table> <thead> <tr> <th>TPM PCR Index</th> <th>Typical Usage of Measurement Register</th> <th>TDX Measurement Register</th> </tr> </thead> <tbody> <tr> <td>0</td> <td>FirmwareCode (BFV, including init page table)</td> <td>MRTD</td> </tr> <tr> <td>1</td> <td>FirmwareData (CFV, TD Hob, ACPI Table, Boot Variable)</td> <td>RTMR[0]</td> </tr> <tr> <td>2</td> <td>Option ROM code</td> <td>RTMR[1]</td> </tr> <tr> <td>3</td> <td>Option ROM code</td> <td>RTMR[1]</td> </tr> <tr> <td>4</td> <td>OS loader code</td> <td>RTMR[1]</td> </tr> <tr> <td>5</td> <td>GUID partition table (GPT)</td> <td>RTMR[1]</td> </tr> <tr> <td>6</td> <td>N/A</td> <td>N/A</td> </tr> <tr> <td>7</td> <td>Secure Boot Configuration</td> <td>RTMR[0]</td> </tr> <tr> <td>8~15</td> <td>TD OS measurement</td> <td>RTMR[2]</td> </tr> </tbody> </table> <p><em>RTMR[3] is reserved for special usage, such as virtual TPM. Users have the flexibility to utilize RTMR[3] if it is not required for these specialized purposes.</em></p> <p>The typical usage of MRTD and RTMR is shown below, more detailes could be found in <a href="https://cdrdv2.intel.com/v1/dl/getContent/733585">8.1 Measurement Register Usage in TD</a>.</p> <ul> <li>MRTD is for the TDVF code (match PCR[0]).</li> <li>RTMR[0] is for the TDVF configuration (match PCR[1,7]). The usage should follow TCG Platform Firmware Profile (PFP) specification.</li> <li>RTMR[1] is for the TDVF loaded component, such as OS loader (match PCR[4,5]). The usage should follow TCG Platform Firmware Profile (PFP) specification.</li> <li>RTMR[2] is for the OS component, such as OS kernel, initrd, and application (match PCR[8~15]). The usage is OS dependent.</li> <li>RTMR[3] is reserved for special usage only.</li> </ul> <h2 id="measured-boot-flow"><strong>Measured Boot Flow</strong></h2> <p>In general, the transitions (dotted line in Booting Sequence figure) where events are measured. Hence a trusted chain, i.e., virtual firmware -&gt; bootloaders -&gt; OS -&gt; applications will be built.</p> <p><strong>Measure TdHob and Configuration FV (Cfv)</strong></p> <p><a href="https://cdrdv2.intel.com/v1/dl/getContent/733585">4.2 TD Hand-Off Block (HOB)</a> and <a href="https://cdrdv2.intel.com/v1/dl/getContent/733585">3.2 Configuration Firmware Volume (CFV)</a> are external data provided by Host VMM. These are not trusted in Td guest. So they should be validated, measured and extended to Td RTMR registers. In the meantime 2 <code class="language-plaintext highlighter-rouge">EFI_CC_EVENT_HOB</code> are created. These 2 GUIDed HOBs carry the hash value of TdHobList and Configuration FV. In DXE phase <code class="language-plaintext highlighter-rouge">EFI_CC_EVENT</code> can be created based on these 2 GUIDed HOBs.</p> <p>Configuration Firmware Volume includes all the provisioned data. This region is read only. One possible usage is to provide UEFI Secure Boot Variable content in this region, such as PK, KEK, db, dbx.</p> <p>The TD HOB list is used to pass the information from VMM to TDVF. The TD HOB must include PHIT HOB, Resource Descriptor HOB. Other HOBs are optional.</p> <ul> <li>The TD HOB must include PHIT HOB as the first HOB. EfiMemoryTop, EfiMemoryBottom, EfiFreeMemoryTop, and EfiFreeMemoryBottom shall be zero.</li> <li>The TD HOB must include at least one Resource Description HOB to declare the physical memory resource.</li> </ul> <p><strong><em>0.</em></strong> <code class="language-plaintext highlighter-rouge">SecTdxHelperLib</code> is the SEC instance of TdxHelperLib. It implements the following functions for tdx in SEC phase:</p> <ul> <li><code class="language-plaintext highlighter-rouge">TdxHelperMeasureTdHob</code> measure/extend TdHob and store the measurement value in workarea.</li> <li><code class="language-plaintext highlighter-rouge">TdxHelperMeasureCfvImage</code> measure/extend the Configuration FV image and store the measurement value in workarea.</li> <li><code class="language-plaintext highlighter-rouge">TdxHelperBuildGuidHobForTdxMeasurement</code> builds GuidHob for tdx measurement.</li> </ul> <p><strong>Measure Secure Boot Policy to PCR[7]/RTMR[0]</strong></p> <p><strong><em>1.</em></strong> UEFI Debug Mode</p> <p>If a platform provides a firmware debugger mode, then the platform shall measure “UEFI Debug Mode” string with <code class="language-plaintext highlighter-rouge">EV_EFI_ACTION</code>. This logic is done at <a href="https://github.com/tianocore/edk2/blob/master/OvmfPkg/Tcg/TdTcg2Dxe/TdTcg2Dxe.c">TdTcg2Dxe.c</a> <code class="language-plaintext highlighter-rouge">MeasureSecureBootPolicy()</code>, based upon <a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/SecurityPkg.dec"><code class="language-plaintext highlighter-rouge">PcdFirmwareDebuggerInitialized</code></a>.</p> <p><strong><em>2.</em></strong> The contents of the <code class="language-plaintext highlighter-rouge">SecureBoot</code> variable</p> <p><strong><em>3.</em></strong> The contents of the <code class="language-plaintext highlighter-rouge">PK</code> variable</p> <p><strong><em>4.</em></strong> The contents of the <code class="language-plaintext highlighter-rouge">KEK</code> variable</p> <p><strong><em>5.</em></strong> The contents of the <code class="language-plaintext highlighter-rouge">EFI_IMAGE_SECURITY_DATABASE</code> variable (the DB)</p> <p><strong><em>6.</em></strong> The contents of the <code class="language-plaintext highlighter-rouge">EFI_IMAGE_SECURITY_DATABASE1</code> variable (the DBX)</p> <p><strong><em>7.</em></strong> The contents of the <code class="language-plaintext highlighter-rouge">EFI_IMAGE_SECURITY_DATABASE2</code> (the DBT) variable, if present and not empty</p> <p>The UEFI secure boot related variables – “SecureBoot”, “PK”, “KEK”, “db”, and “dbx” are unconditionally measured by <a href="https://github.com/tianocore/edk2/blob/master/OvmfPkg/Tcg/TdTcg2Dxe/TdTcg2Dxe.c">TdTcg2Dxe.c</a> <code class="language-plaintext highlighter-rouge">ReadAndMeasureSecureVariable()</code>. The event type is <a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h"><code class="language-plaintext highlighter-rouge">EV_EFI_VARIABLE_DRIVER_CONFIG</code></a>. If they are not present, a zero size UEFI variable entry will be measured. The “dbt” and “dbr” variables are conditionally measured only if they are present by the routine <code class="language-plaintext highlighter-rouge">MeasureAllSecureVariables()</code>.</p> <p><strong><em>8.</em></strong> Separator</p> <p><code class="language-plaintext highlighter-rouge">EV_SEPARATOR</code> for PCR7 is handled in <a href="https://github.com/tianocore/edk2/blob/master/OvmfPkg/Tcg/TdTcg2Dxe/TdTcg2Dxe.c">TdTcg2Dxe.c</a> <code class="language-plaintext highlighter-rouge">MeasureSecureBootPolicy()</code> when the UEFI variable is ready. It is just after <code class="language-plaintext highlighter-rouge">MeasureAllSecureVariables()</code>. It is earlier than the <code class="language-plaintext highlighter-rouge">ReadyToBoot</code> event signal. The reason is that the PCR7 <a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h"><code class="language-plaintext highlighter-rouge">EV_SEPARATOR</code></a> must be between SecureBootPolicy (Configure) and and ImageVerification (Authority).</p> <p><strong>Measure Boot Variable to PCR[1]/RTMR[0]</strong></p> <p><strong><em>9.</em></strong> The UEFI BootOrder Variable and the Boot#### variables (just device paths)</p> <p>The UEFI boot related variables, such as “BootOrder.” and “Boot####” are measured by <a href="https://github.com/tianocore/edk2/blob/master/OvmfPkg/Tcg/TdTcg2Dxe/TdTcg2Dxe.c">TdTcg2Dxe.c</a> <code class="language-plaintext highlighter-rouge">ReadAndMeasureBootVariable()</code>. The event type is <a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h"><code class="language-plaintext highlighter-rouge">EV_EFI_VARIABLE_BOOT</code></a>. These variables are measured if they are present in <code class="language-plaintext highlighter-rouge">MeasureAllBootVariables()</code>.</p> <p><strong>Upon selecting a boot device,</strong></p> <p><strong><em>10.</em></strong> The boot attempt action “Calling EFI Application from Boot Option”, this means Boot Manager attempting to execute code from a Boot Option <strong>(PCR[4]/RTMR[1]</strong>).</p> <p>The boot attempt action is measured by <a href="https://github.com/tianocore/edk2/blob/master/OvmfPkg/Tcg/TdTcg2Dxe/TdTcg2Dxe.c">TdTcg2Dxe.c</a> <code class="language-plaintext highlighter-rouge">OnReadyToBoot()</code>. Before invoking a boot option, it measures the action "Calling EFI Application from Boot Option". After the boot option returns, it measures the action "Returning from EFI Application from Boot Option".</p> <p><strong><em>11.</em></strong> Separator, Draw a line between leaving pre-boot env and entering post-boot env <strong>(PCR[0~6]/RTMR[1])</strong>.</p> <p><strong><em>12.</em></strong> <strong>[Optional] If UEFI Secure Boot is enabled,</strong> measure the entry in the <code class="language-plaintext highlighter-rouge">EFI_IMAGE_SECURITY_DATABASE</code> that was used to validate the UEFI image <strong>(PCR[7]/RTMR[0])</strong>.</p> <p>When UEFI secure boot is enabled, the <a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Library/DxeImageVerificationLib"><code class="language-plaintext highlighter-rouge">DxeImageVerificationLib</code></a> verifies the PE image signature based upon the <a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/Guid/ImageAuthentication.h"><code class="language-plaintext highlighter-rouge">EFI_SIGNATURE_DATA</code></a> in the <a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/Guid/ImageAuthentication.h"><code class="language-plaintext highlighter-rouge">EFI_SIGNATURE_LIST</code></a> of an image signature database. If an <a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/Guid/ImageAuthentication.h"><code class="language-plaintext highlighter-rouge">EFI_SIGNATURE_DATA</code></a> is used to verify the image, then this <a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/Guid/ImageAuthentication.h"><code class="language-plaintext highlighter-rouge">EFI_SIGNATURE_DATA</code></a> will be measured with <a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h"><code class="language-plaintext highlighter-rouge">EV_EFI_VARIABLE_AUTHORITY</code></a> in <a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Library/DxeImageVerificationLib/Measurement.c"><code class="language-plaintext highlighter-rouge">DxeImageVerificationLib</code> Measurement.c</a> <code class="language-plaintext highlighter-rouge">MeasureVariable()</code>.</p> <p><strong><em>13.</em></strong> The GUID Partition Table (GPT) disk geometry <strong>(PCR[5]/RTMR[1])</strong>.</p> <p>When a system boots a boot option in a GUID-named partition of the disk, the GUID partition table (GPT) disk geometry needs to be measured. It is done by <a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Library/DxeTpm2MeasureBootLib/DxeTpm2MeasureBootLib.c">DxeTpm2MeasureBootLib.c</a> <code class="language-plaintext highlighter-rouge">Tcg2MeasureGptTable()</code> in <code class="language-plaintext highlighter-rouge">DxeTpm2MeasureBootHandler()</code>.</p> <p><strong><em>14.</em></strong> The selected UEFI application code PE/COFF image, i.e., OS loader <strong>(PCR[4]/RTMR[1])</strong>.</p> <p>A third party UEFI application, such as a UEFI shell utility, a standard OS loader or an OEM boot option, is measured by <a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Library/DxeTpm2MeasureBootLib/DxeTpm2MeasureBootLib.c">DxeTpm2MeasureBootLib.c</a> <code class="language-plaintext highlighter-rouge">Tcg2MeasurePeImage()</code> in <code class="language-plaintext highlighter-rouge">DxeTpm2MeasureBootHandler()</code>. The event type is <a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h"><code class="language-plaintext highlighter-rouge">EV_EFI_BOOT_SERVICES_APPLICATION</code></a>. If a UEFI application is an FV which is dispatched in the DXE phase, it is also measured to PCR4 irrespective of whether the FV is measured or unmeasured.</p> <p><strong>Then OS loader, i.e., <a href="https://git.savannah.gnu.org/cgit/grub.git/">Grub2</a> extends the trusted boot chain from virtual firmware into the OS.</strong></p> <p><strong><em>15.</em></strong> Grub2 measures configuration file (e.g., grub.cfg), grub commands, kernel binary, kernel commands and initrd binary <strong>(PCR[8, 9]/RTMR[2])</strong> . PCR[8] is for the command line string and PCR[9] is for a file binary, as shown in the following table.</p> <p>To support measurements on confidential computing platforms, two patches have been upstreamed, including:</p> <ul> <li><a href="https://git.savannah.gnu.org/cgit/grub.git/commit/?id=4c76565b6cb885b7e144dc27f3612066844e2d19">efi/tpm: Add EFI_CC_MEASUREMENT_PROTOCOL support</a></li> <li><a href="https://git.savannah.gnu.org/cgit/grub.git/commit/?id=86df79275d065d87f4de5c97e456973e8b4a649c">commands/efi/tpm: Re-enable measurements on confidential computing platforms</a></li> </ul> <table> <thead> <tr> <th><strong>PCR Index</strong></th> <th><strong>PCR Usage</strong></th> </tr> </thead> <tbody> <tr> <td>8</td> <td>Grub command line: All executed commands (including those from configuration files) will be logged and measured as entered with a prefix of “grub cmd: “</td> </tr> <tr> <td> </td> <td>Kernel command line: Any command line passed to a kernel will be logged and measured as entered with a prefix of “kernel cmdline: “</td> </tr> <tr> <td> </td> <td>Module command line: Any command line passed to a kernel module will be logged and measured as entered with a prefix of “module cmdline: “</td> </tr> <tr> <td>9</td> <td>Files: Any file read by GRUB will be logged and measured with a descriptive text corresponding to the filename.</td> </tr> </tbody> </table> <p><a href="https://github.com/rhboot/grub2/blob/master/grub-core/commands/tpm.c">tpm.c</a> registers <code class="language-plaintext highlighter-rouge">grub_tpm_verify_string()</code> and <code class="language-plaintext highlighter-rouge">grub_tpm_verify_write()</code> to a grub_file_verifier structure. They will be called by <code class="language-plaintext highlighter-rouge">grub_verify_string()</code> and <code class="language-plaintext highlighter-rouge">grub_verifiers_open()</code> in <a href="https://github.com/rhboot/grub2/blob/master/grub-core/commands/verifiers.c">verifiers.c</a>.</p> <p>when grub2 executes a command line such as <code class="language-plaintext highlighter-rouge">GRUB_VERIFY_MODULE_CMDLINE</code>, <code class="language-plaintext highlighter-rouge">GRUB_VERIFY_KERNEL_CMDLINE</code>, <code class="language-plaintext highlighter-rouge">GRUB_VERIFY_COMMAND</code> or <code class="language-plaintext highlighter-rouge">grub_create_loader_cmdline()</code> in <a href="https://github.com/rhboot/grub2/blob/master/grub-core/lib/cmdline.c">cmdline.c</a>, <code class="language-plaintext highlighter-rouge">grub_verify_string()</code> is used. Finally, <code class="language-plaintext highlighter-rouge">grub_tpm_verify_string()</code> measures the string to <strong>PCR[8]/RTMR[2]</strong>.</p> <p><code class="language-plaintext highlighter-rouge">grub_verifiers_open()</code> is registered as one of grub_file_filters in <a href="https://github.com/rhboot/grub2/blob/master/include/grub/file.h"><code class="language-plaintext highlighter-rouge">file.h</code></a>. Whenever grub uses <a href="https://github.com/rhboot/grub2/blob/master/grub-core/kern/file.c">file.c</a> <code class="language-plaintext highlighter-rouge">grub_file_open()</code> this filter is invoked. Finally, <code class="language-plaintext highlighter-rouge">grub_tpm_verify_write()</code> measures the file binary to <strong>PCR[9]/RTMR[2]</strong>.</p> <p><strong><em>16.</em></strong> The boot attempt action “Exit Boot Services Invocation”, this means Boot Manager has sent the call to UEFI to end Boot Services <strong>(PCR[5]/RTMR[1])</strong>.</p> <p><strong><em>17.</em></strong> The boot attempt action “Exit Boot Services Returned with Success”, this means UEFI successfully existed Boot Services and pre-OS environment has been terminated <strong>(PCR[5]/RTMR[1])</strong>.</p> <p>The ExitBootServices action is measured by <a href="https://github.com/tianocore/edk2/blob/master/OvmfPkg/Tcg/TdTcg2Dxe/TdTcg2Dxe.c">TdTcg2Dxe.c</a>. If ExitBootServices succeeds, then <code class="language-plaintext highlighter-rouge">OnExitBootServices()</code> is invoked. If ExitBootServices fails, then <code class="language-plaintext highlighter-rouge">OnExitBootServicesFailed()</code> is invoked.</p> <p><strong>If Security Boot Policy update after initial measurement and before <code class="language-plaintext highlighter-rouge">ExitBootServices()</code> has completed,</strong></p> <p><strong><em>18.</em></strong> The platform MAY be restarted OR the variables MUST be remeasured into <strong>(PCR[7]/RTMR[0])</strong>. Additionally the normal update process for setting any of the defined Secure Boot variables SHOULD occur before the initial measurement in PCR[7] or after the call to <code class="language-plaintext highlighter-rouge">ExitBootServices()</code> has completed.</p> <p>The UEFI secure boot variable update is measured in <a href="https://github.com/tianocore/edk2/tree/master/MdeModulePkg/Universal/Variable/RuntimeDxe"><code class="language-plaintext highlighter-rouge">Variable RuntimeDxe</code></a>. If any of the above secure boot related variables are updated, then <a href="https://github.com/tianocore/edk2/blob/master/MdeModulePkg/Universal/Variable/RuntimeDxe/Measurement.c">Variable RuntimeDxe Measurement.c</a> <code class="language-plaintext highlighter-rouge">MeasureVariable()</code> will measure the new data with <a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h"><code class="language-plaintext highlighter-rouge">EV_EFI_VARIABLE_DRIVER_CONFIG</code></a>.</p> <h2 id="attestation">Attestation</h2> <p>To be Updated…</p> <p><a href="https://github.com/google/go-eventlog">go-eventlog</a></p> <p><a href="https://github.com/canonical/tdx">tdx</a></p> <h2 id="annex-a-configurations-for-tdvf">Annex A: Configurations for TDVF</h2> <p><strong>Config-A</strong>:</p> <ul> <li>Merge the <em>basic</em> TDVF feature to existing <code class="language-plaintext highlighter-rouge">OvmfX64Pkg.dsc</code>. (Align with existing SEV)</li> <li>Threat model: VMM is NOT out of TCB. (We don’t make things worse)</li> <li>The <code class="language-plaintext highlighter-rouge">OvmfX64Pkg.dsc</code> includes SEV/TDX/normal OVMF basic boot capability. The final binary can run on SEV/TDX/normal OVMF.</li> <li>No changes to existing OvmfPkgX64 image layout.</li> <li>No need to remove features if they exist today.</li> <li>PEI phase is NOT skipped in either Td or Non-Td.</li> <li>RTMR based measurement is supported.</li> <li>External inputs from Host VMM are measured, such as TdHob, CFV.</li> <li>Other external inputs are measured, such as FW_CFG data, os loader, initrd, etc.</li> </ul> <p><strong>Build the TDVF (Config-A) target:</strong></p> <p><a href="https://git.codelinaro.org/linaro/dcap/edk2/-/commit/4d37059d8e1eeda124270a158416795605327cbd">OvmfPkg: Support Tdx measurement in OvmfPkgX64</a></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd /path/to/edk2
source edksetup.sh
build.sh -p OvmfPkg/OvmfPkgX64.dsc -a X64 -t GCC5
</code></pre></div></div> <p><strong>Config-B</strong>:</p> <ul> <li>Add a standalone <code class="language-plaintext highlighter-rouge">IntelTdx.dsc</code> to a TDX specific directory for a <em>full</em>  feature TDVF.(Align with existing SEV)</li> <li>Threat model: VMM is out of TCB. (We need necessary change to prevent attack from VMM)</li> <li><code class="language-plaintext highlighter-rouge">IntelTdx.dsc</code> includes TDX/normal OVMF basic boot capability. The final binary can run on TDX/normal OVMF.</li> <li>It might eventually merge with AmdSev.dsc, but NOT at this point of time. And we don’t know when it will happen. We need sync with AMD in the community after both of us think the solutions are mature to merge.</li> <li>Need to add necessary security feature as mandatory requirement, such as RTMR based Trusted Boot support.</li> <li>Need to measure the external input from Host VMM, such as TdHob, CFV.</li> <li>Need to measure other external input, such as FW_CFG data, os loader, initrd, etc.</li> <li>Need to remove unnecessary attack surfaces, such as network stack.</li> </ul> <p><strong>Build the TDVF (Config-B) target:</strong></p> <p><a href="https://git.codelinaro.org/linaro/dcap/edk2/-/commit/44a53a3bdd9c76e37f1750b5aa6a745de5d77391">OvmfPkg: Introduce IntelTdxX64 for TDVF Config-B</a></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd /path/to/edk2
set PACKAGES_PATH=/path/to/edk2/OvmfPkg
source edksetup.sh
build.sh -p OvmfPkg/IntelTdx/IntelTdxX64.dsc -a X64 -t GCC5
</code></pre></div></div> <h2 id="annex-b-uefi-boot-phase">Annex B: UEFI Boot Phase</h2> <p>UEFI has six main boot phases, which are all critical in the initialization process of the platform. The combined phases are referred to as the Platform Initialization or PI.</p> <p><strong><em>1.</em></strong> Security (SEC)</p> <p>This phase is the primary stage of the UEFI boot process, and will generally be used to: initialize a temporary memory store, act as the root of trust in the system and provide information to the Pre-EFI core phase. This root of trust is a mechanism that ensures any code that is executed in the PI is cryptographically validated (digitally signed), creating a “secure boot” environment.</p> <p><strong><em>2.</em></strong> Pre-EFI Initialization (PEI)</p> <p>This is the second stage of the boot process and involves using only the CPU’s current resources to dispatch Pre-EFI Initialization Modules (PEIMs). These are used to perform initialization of specific boot-critical operations such as memory initialization, whilst also allowing control to pass to the Driver Execution Environment (DXE).</p> <p><strong><em>3.</em></strong> Driver Execution Environment (DXE)</p> <p>The DXE phase is where the majority of the system initialization occurs. In the PEI stage, the memory required for the DXE to operate is allocated and initialized, and upon control being passed to the DXE, the DXE Dispatcher is then invoked. The dispatcher will perform the loading and execution of hardware drivers, runtime services, and any boot services required for the operating system to start.</p> <p><strong><em>4.</em></strong> Boot Device Selection (BDS)</p> <p>Upon completion of the DXE Dispatcher executing all DXE drivers, control is passed to the BDS. This stage is responsible for initializing console devices and any remaining devices that are required. The selected boot entry (OS loader) is then loaded and executed in preparation for the Transient System Load (TSL).</p> <p><strong><em>5.</em></strong> Transient System Load (TSL)</p> <p>In this phase, the PI process is now directly between the boot selection and the expected hand-off to the main operating system phase. Here, an application such as the UEFI shell may be invoked, or (more commonly) a boot loader will run in order to prepare the final OS environment. The boot loader is usually responsible for terminating the UEFI Boot Services via the ExitBootServices() call. However, it is also possible for the OS itself to do this, such as the Linux kernel with CONFIG_EFI_STUB.</p> <p><strong><em>6.</em></strong> Runtime (RT)</p> <p>The final phase is the runtime one. Here is where the final handoff to the OS occurs. The UEFI compatible OS now takes over the system. The UEFI runtime services remain available for the OS to use, such as for querying and writing variables from NVRAM.</p>]]></content><author><name></name></author><category term="cc"/><category term="tdx"/><category term="measurement"/><category term="attestation"/><summary type="html"><![CDATA[How to build a trusted chain when launch TD guest using grub boot.]]></summary></entry></feed>